{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def _list_artifacts_mlflow_artifacts():\n    \"\"\"\n    A request handler for `GET /mlflow-artifacts/artifacts?path=<value>` to list artifacts in `path`\n    (a relative path from the root artifact directory).\n    \"\"\"\n    request_message = _get_request_message(ListArtifactsMlflowArtifacts())\n    if request_message.HasField(\"path\"):\n        validate_path_is_safe(request_message.path)\n        path = request_message.path\n    else:\n        path = None\n    artifact_repo = _get_artifact_repo_mlflow_artifacts()\n    files = []\n    for file_info in artifact_repo.list_artifacts(path):\n        basename = posixpath.basename(file_info.path)\n        new_file_info = FileInfo(basename, file_info.is_dir, file_info.file_size)\n        files.append(new_file_info.to_proto())\n    response_message = ListArtifacts.Response()\n    response_message.files.extend(files)\n    response = Response(mimetype=\"application/json\")\n    response.set_data(message_to_json(response_message))\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve_protected_file(request, path):\n    \"\"\"\n    Function that serves protected files uploaded from forms.\n    \"\"\"\n    fullpath = os.path.join(cr_settings['PROTECTED_MEDIA_ROOT'], path)\n    if os.path.isfile(fullpath):\n        mimetype, encoding = mimetypes.guess_type(fullpath)\n        with open(fullpath, 'rb') as f:\n            response = HttpResponse(f.read(), content_type=mimetype)\n        if encoding:\n            response[\"Content-Encoding\"] = encoding\n\n        return response\n    raise Http404()\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def traverse(cls, base, request, path_items):\n        \"\"\"See ``zope.app.pagetemplate.engine``.\"\"\"\n\n        path_items = list(path_items)\n        path_items.reverse()\n\n        while path_items:\n            name = path_items.pop()\n            if ITraversable.providedBy(base):\n                base = getattr(base, cls.traverseMethod)(name)\n            else:\n                base = traversePathElement(base, name, path_items,\n                                           request=request)\n\n        return base\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def put_file(path):\n    try:\n        dest_path = sanitized_join(\n            path,\n            pathlib.Path(app.config[\"DATA_ROOT\"]),\n        )\n    except ValueError:\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    verification_key = flask.request.args.get(\"v\", \"\")\n    length = int(flask.request.headers.get(\"Content-Length\", 0))\n    hmac_input = \"{} {}\".format(path, length).encode(\"utf-8\")\n    key = app.config[\"SECRET_KEY\"]\n    mac = hmac.new(key, hmac_input, hashlib.sha256)\n    digest = mac.hexdigest()\n\n    if not hmac.compare_digest(digest, verification_key):\n        return flask.Response(\n            \"Invalid verification key\",\n            403,\n            mimetype=\"text/plain\",\n        )\n\n    content_type = flask.request.headers.get(\n        \"Content-Type\",\n        \"application/octet-stream\",\n    )\n\n    dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n    data_file, metadata_file = get_paths(dest_path)\n\n    try:\n        with write_file(data_file) as fout:\n            stream_file(flask.request.stream, fout, length)\n\n            with metadata_file.open(\"x\") as f:\n                json.dump(\n                    {\n                        \"headers\": {\"Content-Type\": content_type},\n                    },\n                    f,\n                )\n    except EOFError:\n        return flask.Response(\n            \"Bad Request\",\n            400,\n            mimetype=\"text/plain\",\n        )\n    except OSError as exc:\n        if exc.errno == errno.EEXIST:\n            return flask.Response(\n                \"Conflict\",\n                409,\n                mimetype=\"text/plain\",\n            )\n        raise\n\n    return flask.Response(\n        \"Created\",\n        201,\n        mimetype=\"text/plain\",\n    )\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def save(self, name, content, max_length=None):\n        \"\"\"\n        Save new content to the file specified by name. The content should be\n        a proper File object or any Python file-like object, ready to be read\n        from the beginning.\n        \"\"\"\n        # Get the proper name for the file, as it will actually be saved.\n        if name is None:\n            name = content.name\n\n        if not hasattr(content, 'chunks'):\n            content = File(content, name)\n\n        name = self.get_available_name(name, max_length=max_length)\n        return self._save(name, content)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def include_is_allowed(filepath):\n    for root in settings.ALLOWED_INCLUDE_ROOTS:\n        if filepath.startswith(root):\n            return True\n    return False\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_object_src_http(dataset, rel_path):\n    path = _get_obj_abosolute_path(dataset, rel_path)\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def is_in_or_equal(path_1: str | Path, path_2: str | Path):\n    \"\"\"\n    True if path_1 is a descendant (i.e. located within) path_2 or if the paths are the\n    same, returns False otherwise.\n    Parameters:\n        path_1: str or Path (should be a file)\n        path_2: str or Path (can be a file or directory)\n    \"\"\"\n    path_1, path_2 = abspath(path_1), abspath(path_2)\n    try:\n        if str(path_1.relative_to(path_2)).startswith(\"..\"):  # prevent path traversal\n            return False\n    except ValueError:\n        return False\n    return True\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def validate_path_is_safe(path):\n    \"\"\"\n    Validates that the specified path is safe to join with a trusted prefix. This is a security\n    measure to prevent path traversal attacks.\n    A valid path should:\n        not contain separators other than '/'\n        not contain .. to navigate to parent dir in path\n        not be an absolute path\n    \"\"\"\n    from mlflow.utils.file_utils import local_file_uri_to_path\n\n    exc = MlflowException(f\"Invalid path: {path}\", error_code=INVALID_PARAMETER_VALUE)\n    if any((s in path) for s in (\"#\", \"%23\")):\n        raise exc\n\n    if is_file_uri(path):\n        path = local_file_uri_to_path(path)\n    if (\n        any((s in path) for s in _OS_ALT_SEPS)\n        or \"..\" in path.split(\"/\")\n        or pathlib.PureWindowsPath(path).is_absolute()\n        or pathlib.PurePosixPath(path).is_absolute()\n        or (is_windows() and len(path) >= 2 and path[1] == \":\")\n    ):\n        raise exc\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def file(path):\n    path = secure_filename(path)\n    if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):\n        with open(os.path.join(app.cwd, path), \"rb\") as encrypted_file:\n            encrypted_data = encrypted_file.read()\n        file_data = encryptor.decrypt(\n            app.interface.encryption_key, encrypted_data)\n        return send_file(io.BytesIO(file_data), attachment_filename=os.path.basename(path))\n    else:\n        return send_file(os.path.join(app.cwd, path))\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def writef(self, bio: IO[Any], arcname: str):\n        if isinstance(bio, io.BytesIO):\n            size = bio.getbuffer().nbytes\n        elif isinstance(bio, io.TextIOBase):\n            # First check whether is it Text?\n            raise ValueError(\"Unsupported file object type: please open file with Binary mode.\")\n        elif isinstance(bio, io.BufferedIOBase):\n            # come here when subtype of io.BufferedIOBase that don't have __sizeof__ (eg. pypy)\n            # alternative for `size = bio.__sizeof__()`\n            current = bio.tell()\n            bio.seek(0, os.SEEK_END)\n            last = bio.tell()\n            bio.seek(current, os.SEEK_SET)\n            size = last - current\n        else:\n            raise ValueError(\"Wrong argument passed for argument bio.\")\n        if size > 0:\n            folder = self.header.initialize()\n            file_info = self._make_file_info_from_name(bio, size, arcname)\n            self.header.files_info.files.append(file_info)\n            self.header.files_info.emptyfiles.append(file_info[\"emptystream\"])\n            self.files.append(file_info)\n            self.worker.archive(self.fp, self.files, folder, deref=False)\n        else:\n            file_info = self._make_file_info_from_name(bio, size, arcname)\n            self.header.files_info.files.append(file_info)\n            self.header.files_info.emptyfiles.append(file_info[\"emptystream\"])\n            self.files.append(file_info)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def is_local_uri(uri, is_tracking_or_registry_uri=True):\n    \"\"\"\n    Returns true if the specified URI is a local file path (/foo or file:/foo).\n\n    :param uri: The URI.\n    :param is_tracking_uri: Whether or not the specified URI is an MLflow Tracking or MLflow\n                            Model Registry URI. Examples of other URIs are MLflow artifact URIs,\n                            filesystem paths, etc.\n    \"\"\"\n    if uri == \"databricks\" and is_tracking_or_registry_uri:\n        return False\n\n    if is_windows() and uri.startswith(\"\\\\\\\\\"):\n        # windows network drive path looks like: \"\\\\<server name>\\path\\...\"\n        return False\n\n    parsed_uri = urllib.parse.urlparse(uri)\n    if parsed_uri.hostname and not (\n        parsed_uri.hostname == \".\"\n        or parsed_uri.hostname.startswith(\"localhost\")\n        or parsed_uri.hostname.startswith(\"127.0.0.1\")\n    ):\n        return False\n\n    scheme = parsed_uri.scheme\n    if scheme == \"\" or scheme == \"file\":\n        return True\n\n    if is_windows() and len(scheme) == 1 and scheme.lower() == pathlib.Path(uri).drive.lower()[0]:\n        return True\n\n    return False\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def get_available_name(self, name, max_length=None):\n        \"\"\"\n        Return a filename that's free on the target storage system and\n        available for new content to be written to.\n        \"\"\"\n        dir_name, file_name = os.path.split(name)\n        if '..' in pathlib.PurePath(dir_name).parts:\n            raise SuspiciousFileOperation(\"Detected path traversal attempt in '%s'\" % dir_name)\n        validate_file_name(file_name)\n        file_root, file_ext = os.path.splitext(file_name)\n        # If the filename already exists, generate an alternative filename\n        # until it doesn't exist.\n        # Truncate original name if required, so the new filename does not\n        # exceed the max_length.\n        while self.exists(name) or (max_length and len(name) > max_length):\n            # file_ext includes the dot.\n            name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))\n            if max_length is None:\n                continue\n            # Truncate file_root if max_length exceeded.\n            truncation = len(name) - max_length\n            if truncation > 0:\n                file_root = file_root[:-truncation]\n                # Entire file_root was truncated in attempt to find an available filename.\n                if not file_root:\n                    raise SuspiciousFileOperation(\n                        'Storage can not find an available filename for \"%s\". '\n                        'Please make sure that the corresponding file field '\n                        'allows sufficient \"max_length\".' % name\n                    )\n                name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))\n        return name\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def _complete_multipart_upload_artifact(artifact_path):\n    \"\"\"\n    A request handler for `POST /mlflow-artifacts/mpu/complete` to complete a multipart upload\n    to `artifact_path` (a relative path from the root artifact directory).\n    \"\"\"\n    validate_path_is_safe(artifact_path)\n\n    request_message = _get_request_message(\n        CompleteMultipartUpload(),\n        schema={\n            \"path\": [_assert_required, _assert_string],\n            \"upload_id\": [_assert_string],\n            \"parts\": [_assert_required],\n        },\n    )\n    path = request_message.path\n    upload_id = request_message.upload_id\n    parts = [MultipartUploadPart.from_proto(part) for part in request_message.parts]\n\n    artifact_repo = _get_artifact_repo_mlflow_artifacts()\n    _validate_support_multipart_upload(artifact_repo)\n\n    artifact_repo.complete_multipart_upload(\n        path,\n        upload_id,\n        parts,\n        artifact_path,\n    )\n    return _wrap_response(CompleteMultipartUpload.Response())\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _extract_single(\n        self,\n        fp: BinaryIO,\n        files,\n        src_end: int,\n        q: Optional[queue.Queue],\n        skip_notarget=True,\n    ) -> None:\n        \"\"\"\n        Single thread extractor that takes file lists in single 7zip folder.\n        this may raise exception.\n        \"\"\"\n        just_check: List[ArchiveFile] = []\n        for f in files:\n            if q is not None:\n                q.put(\n                    (\n                        \"s\",\n                        str(f.filename),\n                        str(f.compressed) if f.compressed is not None else \"0\",\n                    )\n                )\n            fileish = self.target_filepath.get(f.id, None)\n            if fileish is None:\n                if not f.emptystream:\n                    just_check.append(f)\n            else:\n                # delayed execution of crc check.\n                self._check(fp, just_check, src_end)\n                just_check = []\n                fileish.parent.mkdir(parents=True, exist_ok=True)\n                if not f.emptystream:\n                    if f.is_junction and not isinstance(fileish, MemIO) and sys.platform == \"win32\":\n                        with io.BytesIO() as ofp:\n                            self.decompress(fp, f.folder, ofp, f.uncompressed, f.compressed, src_end)\n                            dst: str = ofp.read().decode(\"utf-8\")\n                            # fileish.unlink(missing_ok=True) > py3.7\n                            if fileish.exists():\n                                fileish.unlink()\n                            if sys.platform == \"win32\":  # hint for mypy\n                                _winapi.CreateJunction(str(fileish), dst)  # noqa\n                    elif f.is_symlink and not isinstance(fileish, MemIO):\n                        with io.BytesIO() as omfp:\n                            self.decompress(fp, f.folder, omfp, f.uncompressed, f.compressed, src_end)\n                            omfp.seek(0)\n                            sym_target = pathlib.Path(omfp.read().decode(\"utf-8\"))\n                            # fileish.unlink(missing_ok=True) > py3.7\n                            if fileish.exists():\n                                fileish.unlink()\n                            fileish.symlink_to(sym_target)\n                    else:\n                        with fileish.open(mode=\"wb\") as obfp:\n                            crc32 = self.decompress(fp, f.folder, obfp, f.uncompressed, f.compressed, src_end)\n                            obfp.seek(0)\n                            if f.crc32 is not None and crc32 != f.crc32:\n                                raise CrcError(crc32, f.crc32, f.filename)\n                else:\n                    # just create empty file\n                    if not isinstance(fileish, MemIO):\n                        fileish.touch()\n                    else:\n                        with fileish.open() as ofp:\n                            pass\n            if q is not None:\n                q.put((\"e\", str(f.filename), str(f.uncompressed)))\n        if not skip_notarget:\n            # delayed execution of crc check.\n            self._check(fp, just_check, src_end)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def _list_artifacts_mlflow_artifacts():\n    \"\"\"\n    A request handler for `GET /mlflow-artifacts/artifacts?path=<value>` to list artifacts in `path`\n    (a relative path from the root artifact directory).\n    \"\"\"\n    request_message = _get_request_message(ListArtifactsMlflowArtifacts())\n    path = validate_path_is_safe(request_message.path) if request_message.HasField(\"path\") else None\n    artifact_repo = _get_artifact_repo_mlflow_artifacts()\n    files = []\n    for file_info in artifact_repo.list_artifacts(path):\n        basename = posixpath.basename(file_info.path)\n        new_file_info = FileInfo(basename, file_info.is_dir, file_info.file_size)\n        files.append(new_file_info.to_proto())\n    response_message = ListArtifacts.Response()\n    response_message.files.extend(files)\n    response = Response(mimetype=\"application/json\")\n    response.set_data(message_to_json(response_message))\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve_protected_file(request, path):\n    \"\"\"\n    Function that serves protected files uploaded from forms.\n    \"\"\"\n    # Fully resolve all provided paths.\n    mediapath = os.path.abspath(cr_settings['PROTECTED_MEDIA_ROOT'])\n    fullpath = os.path.abspath(os.path.join(mediapath, path))\n\n    # Path must be a sub-path of the PROTECTED_MEDIA_ROOT, and exist.\n    if fullpath.startswith(mediapath) and os.path.isfile(fullpath):\n        mimetype, encoding = mimetypes.guess_type(fullpath)\n        with open(fullpath, 'rb') as f:\n            response = HttpResponse(f.read(), content_type=mimetype)\n        if encoding:\n            response[\"Content-Encoding\"] = encoding\n\n        return response\n    raise Http404()\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def traverse(cls, base, request, path_items):\n        \"\"\"See ``zope.app.pagetemplate.engine``.\"\"\"\n\n        path_items = list(path_items)\n        path_items.reverse()\n\n        while path_items:\n            name = path_items.pop()\n\n            if name == '_':\n                warnings.warn('Traversing to the name `_` is deprecated '\n                              'and will be removed in Zope 6.',\n                              DeprecationWarning)\n            elif name.startswith('_'):\n                raise NotFound(name)\n\n            if ITraversable.providedBy(base):\n                base = getattr(base, cls.traverse_method)(name)\n            else:\n                base = traversePathElement(base, name, path_items,\n                                           request=request)\n\n        return base\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def put_file(path):\n    try:\n        data_file, metadata_file = get_paths(app.config[\"DATA_ROOT\"], path)\n    except werkzeug.exceptions.NotFound:\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    verification_key = flask.request.args.get(\"v\", \"\")\n    length = int(flask.request.headers.get(\"Content-Length\", 0))\n    hmac_input = \"{} {}\".format(path, length).encode(\"utf-8\")\n    key = app.config[\"SECRET_KEY\"]\n    mac = hmac.new(key, hmac_input, hashlib.sha256)\n    digest = mac.hexdigest()\n\n    if not hmac.compare_digest(digest, verification_key):\n        return flask.Response(\n            \"Invalid verification key\",\n            403,\n            mimetype=\"text/plain\",\n        )\n\n    content_type = flask.request.headers.get(\n        \"Content-Type\",\n        \"application/octet-stream\",\n    )\n\n    data_file.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n\n    try:\n        with write_file(data_file) as fout:\n            stream_file(flask.request.stream, fout, length)\n\n            with metadata_file.open(\"x\") as f:\n                json.dump(\n                    {\n                        \"headers\": {\"Content-Type\": content_type},\n                    },\n                    f,\n                )\n    except EOFError:\n        return flask.Response(\n            \"Bad Request\",\n            400,\n            mimetype=\"text/plain\",\n        )\n    except OSError as exc:\n        if exc.errno == errno.EEXIST:\n            return flask.Response(\n                \"Conflict\",\n                409,\n                mimetype=\"text/plain\",\n            )\n        raise\n\n    return flask.Response(\n        \"Created\",\n        201,\n        mimetype=\"text/plain\",\n    )\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def save(self, name, content, max_length=None):\n        \"\"\"\n        Save new content to the file specified by name. The content should be\n        a proper File object or any Python file-like object, ready to be read\n        from the beginning.\n        \"\"\"\n        # Get the proper name for the file, as it will actually be saved.\n        if name is None:\n            name = content.name\n\n        if not hasattr(content, 'chunks'):\n            content = File(content, name)\n\n        name = self.get_available_name(name, max_length=max_length)\n        name = self._save(name, content)\n        # Ensure that the name returned from the storage system is still valid.\n        validate_file_name(name, allow_relative_path=True)\n        return name\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def include_is_allowed(filepath):\n    filepath = os.path.abspath(filepath)\n    for root in settings.ALLOWED_INCLUDE_ROOTS:\n        if filepath.startswith(root):\n            return True\n    return False\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_object_src_http(dataset, rel_path):\n    path = _get_obj_absolute_path(dataset, rel_path)\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def is_in_or_equal(path_1: str | Path, path_2: str | Path):\n    \"\"\"\n    True if path_1 is a descendant (i.e. located within) path_2 or if the paths are the\n    same, returns False otherwise.\n    Parameters:\n        path_1: str or Path (should be a file)\n        path_2: str or Path (can be a file or directory)\n    \"\"\"\n    path_1, path_2 = abspath(path_1), abspath(path_2)\n    try:\n        if \"..\" in str(path_1.relative_to(path_2)):  # prevent path traversal\n            return False\n    except ValueError:\n        return False\n    return True\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def validate_path_is_safe(path):\n    \"\"\"\n    Validates that the specified path is safe to join with a trusted prefix. This is a security\n    measure to prevent path traversal attacks.\n    A valid path should:\n        not contain separators other than '/'\n        not contain .. to navigate to parent dir in path\n        not be an absolute path\n    \"\"\"\n    from mlflow.utils.file_utils import local_file_uri_to_path\n\n    # We must decode URL before validating it\n    path = urllib.parse.unquote(path)\n\n    exc = MlflowException(\"Invalid path\", error_code=INVALID_PARAMETER_VALUE)\n    if any((s in path) for s in (\"#\", \"%23\")):\n        raise exc\n\n    if is_file_uri(path):\n        path = local_file_uri_to_path(path)\n    if (\n        any((s in path) for s in _OS_ALT_SEPS)\n        or \"..\" in path.split(\"/\")\n        or pathlib.PureWindowsPath(path).is_absolute()\n        or pathlib.PurePosixPath(path).is_absolute()\n        or (is_windows() and len(path) >= 2 and path[1] == \":\")\n    ):\n        raise exc\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def file(path):\n    if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):\n        with open(safe_join(app.cwd, path), \"rb\") as encrypted_file:\n            encrypted_data = encrypted_file.read()\n        file_data = encryptor.decrypt(\n            app.interface.encryption_key, encrypted_data)\n        return send_file(io.BytesIO(file_data), attachment_filename=os.path.basename(path))\n    else:\n        return send_file(safe_join(app.cwd, path))\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def writef(self, bio: IO[Any], arcname: str):\n        if not check_archive_path(arcname):\n            raise ValueError(f\"Specified path is bad: {arcname}\")\n        return self._writef(bio, arcname)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def is_local_uri(uri, is_tracking_or_registry_uri=True):\n    \"\"\"\n    Returns true if the specified URI is a local file path (/foo or file:/foo).\n\n    :param uri: The URI.\n    :param is_tracking_uri: Whether or not the specified URI is an MLflow Tracking or MLflow\n                            Model Registry URI. Examples of other URIs are MLflow artifact URIs,\n                            filesystem paths, etc.\n    \"\"\"\n    if uri == \"databricks\" and is_tracking_or_registry_uri:\n        return False\n\n    if is_windows() and uri.startswith(\"\\\\\\\\\"):\n        # windows network drive path looks like: \"\\\\<server name>\\path\\...\"\n        return False\n\n    parsed_uri = urllib.parse.urlparse(uri)\n    scheme = parsed_uri.scheme\n    if scheme == \"\":\n        return True\n\n    if parsed_uri.hostname and not (\n        parsed_uri.hostname == \".\"\n        or parsed_uri.hostname.startswith(\"localhost\")\n        or parsed_uri.hostname.startswith(\"127.0.0.1\")\n    ):\n        return False\n\n    if scheme == \"file\":\n        return True\n\n    if is_windows() and len(scheme) == 1 and scheme.lower() == pathlib.Path(uri).drive.lower()[0]:\n        return True\n\n    return False\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def get_available_name(self, name, max_length=None):\n        \"\"\"\n        Return a filename that's free on the target storage system and\n        available for new content to be written to.\n        \"\"\"\n        name = str(name).replace('\\\\', '/')\n        dir_name, file_name = os.path.split(name)\n        if '..' in pathlib.PurePath(dir_name).parts:\n            raise SuspiciousFileOperation(\"Detected path traversal attempt in '%s'\" % dir_name)\n        validate_file_name(file_name)\n        file_root, file_ext = os.path.splitext(file_name)\n        # If the filename already exists, generate an alternative filename\n        # until it doesn't exist.\n        # Truncate original name if required, so the new filename does not\n        # exceed the max_length.\n        while self.exists(name) or (max_length and len(name) > max_length):\n            # file_ext includes the dot.\n            name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))\n            if max_length is None:\n                continue\n            # Truncate file_root if max_length exceeded.\n            truncation = len(name) - max_length\n            if truncation > 0:\n                file_root = file_root[:-truncation]\n                # Entire file_root was truncated in attempt to find an available filename.\n                if not file_root:\n                    raise SuspiciousFileOperation(\n                        'Storage can not find an available filename for \"%s\". '\n                        'Please make sure that the corresponding file field '\n                        'allows sufficient \"max_length\".' % name\n                    )\n                name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))\n        return name\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def _complete_multipart_upload_artifact(artifact_path):\n    \"\"\"\n    A request handler for `POST /mlflow-artifacts/mpu/complete` to complete a multipart upload\n    to `artifact_path` (a relative path from the root artifact directory).\n    \"\"\"\n    artifact_path = validate_path_is_safe(artifact_path)\n\n    request_message = _get_request_message(\n        CompleteMultipartUpload(),\n        schema={\n            \"path\": [_assert_required, _assert_string],\n            \"upload_id\": [_assert_string],\n            \"parts\": [_assert_required],\n        },\n    )\n    path = request_message.path\n    upload_id = request_message.upload_id\n    parts = [MultipartUploadPart.from_proto(part) for part in request_message.parts]\n\n    artifact_repo = _get_artifact_repo_mlflow_artifacts()\n    _validate_support_multipart_upload(artifact_repo)\n\n    artifact_repo.complete_multipart_upload(\n        path,\n        upload_id,\n        parts,\n        artifact_path,\n    )\n    return _wrap_response(CompleteMultipartUpload.Response())\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _extract_single(\n        self,\n        fp: BinaryIO,\n        files,\n        path,\n        src_end: int,\n        q: Optional[queue.Queue],\n        skip_notarget=True,\n    ) -> None:\n        \"\"\"\n        Single thread extractor that takes file lists in single 7zip folder.\n        this may raise exception.\n        \"\"\"\n        just_check: List[ArchiveFile] = []\n        for f in files:\n            if q is not None:\n                q.put(\n                    (\n                        \"s\",\n                        str(f.filename),\n                        str(f.compressed) if f.compressed is not None else \"0\",\n                    )\n                )\n            fileish = self.target_filepath.get(f.id, None)\n            if fileish is None:\n                if not f.emptystream:\n                    just_check.append(f)\n            else:\n                # delayed execution of crc check.\n                self._check(fp, just_check, src_end)\n                just_check = []\n                fileish.parent.mkdir(parents=True, exist_ok=True)\n                if not f.emptystream:\n                    if f.is_junction and not isinstance(fileish, MemIO) and sys.platform == \"win32\":\n                        with io.BytesIO() as ofp:\n                            self.decompress(fp, f.folder, ofp, f.uncompressed, f.compressed, src_end)\n                            dst: str = ofp.read().decode(\"utf-8\")\n                            if is_target_path_valid(path, fileish.parent.joinpath(dst)):\n                                # fileish.unlink(missing_ok=True) > py3.7\n                                if fileish.exists():\n                                    fileish.unlink()\n                                if sys.platform == \"win32\":  # hint for mypy\n                                    _winapi.CreateJunction(str(fileish), dst)  # noqa\n                            else:\n                                raise Bad7zFile(\"Junction point out of target directory.\")\n                    elif f.is_symlink and not isinstance(fileish, MemIO):\n                        with io.BytesIO() as omfp:\n                            self.decompress(fp, f.folder, omfp, f.uncompressed, f.compressed, src_end)\n                            omfp.seek(0)\n                            dst = omfp.read().decode(\"utf-8\")\n                            # check sym_target points inside an archive target?\n                            if is_target_path_valid(path, fileish.parent.joinpath(dst)):\n                                sym_target = pathlib.Path(dst)\n                                # fileish.unlink(missing_ok=True) > py3.7\n                                if fileish.exists():\n                                    fileish.unlink()\n                                fileish.symlink_to(sym_target)\n                            else:\n                                raise Bad7zFile(\"Symlink point out of target directory.\")\n                    else:\n                        with fileish.open(mode=\"wb\") as obfp:\n                            crc32 = self.decompress(fp, f.folder, obfp, f.uncompressed, f.compressed, src_end)\n                            obfp.seek(0)\n                            if f.crc32 is not None and crc32 != f.crc32:\n                                raise CrcError(crc32, f.crc32, f.filename)\n                else:\n                    # just create empty file\n                    if not isinstance(fileish, MemIO):\n                        fileish.touch()\n                    else:\n                        with fileish.open() as ofp:\n                            pass\n            if q is not None:\n                q.put((\"e\", str(f.filename), str(f.uncompressed)))\n        if not skip_notarget:\n            # delayed execution of crc check.\n            self._check(fp, just_check, src_end)\n"}, {"role": "assistant", "content": "False"}]}
