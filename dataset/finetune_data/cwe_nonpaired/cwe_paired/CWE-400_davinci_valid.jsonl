{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def to_python(self, value):\n        return unicodedata.normalize(\"NFKC\", super().to_python(value))\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def get_available_name(self, name):\n        \"\"\"\n        Returns a filename that's free on the target storage system, and\n        available for new content to be written to.\n        \"\"\"\n        dir_name, file_name = os.path.split(name)\n        file_root, file_ext = os.path.splitext(file_name)\n        # If the filename already exists, add an underscore and a number (before\n        # the file extension, if one exists) to the filename until the generated\n        # filename doesn't exist.\n        count = itertools.count(1)\n        while self.exists(name):\n            # file_ext includes the dot.\n            name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, next(count), file_ext))\n\n        return name\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        >>> parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        >>> parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        >>> parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    is_string = not isinstance(url, six.binary_type)\n    if not is_string:\n        url = url.decode(\"utf-8\")\n\n    # RFC 3986 doesn't like URLs that have a host but don't start\n    # with a scheme and we support URLs like that so we need to\n    # detect that problem and add an empty scheme indication.\n    # We don't get hurt on path-only URLs here as it's stripped\n    # off and given an empty scheme anyways.\n    if not SCHEME_REGEX.search(url):\n        url = \"//\" + url\n\n    try:\n        iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")\n    except (ValueError, RFC3986Exception):\n        six.raise_from(LocationParseError(url), None)\n\n    def idna_encode(name):\n        if name and any([ord(x) > 128 for x in name]):\n            try:\n                import idna\n            except ImportError:\n                raise LocationParseError(\"Unable to parse URL without the 'idna' module\")\n            try:\n                return idna.encode(name.lower(), strict=True, std3_rules=True)\n            except idna.IDNAError:\n                raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)\n        return name\n\n    has_authority = iri_ref.authority is not None\n    uri_ref = iri_ref.encode(idna_encoder=idna_encode)\n\n    # rfc3986 strips the authority if it's invalid\n    if has_authority and uri_ref.authority is None:\n        raise LocationParseError(url)\n\n    # Only normalize schemes we understand to not break http+unix\n    # or other schemes that don't follow RFC 3986.\n    if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:\n        uri_ref = uri_ref.normalize()\n\n    # Validate all URIReference components and ensure that all\n    # components that were set before are still set after\n    # normalization has completed.\n    validator = Validator()\n    try:\n        validator.check_validity_of(\n            *validator.COMPONENT_NAMES\n        ).validate(uri_ref)\n    except ValidationError:\n        six.raise_from(LocationParseError(url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    path = uri_ref.path\n    if not path:\n        if (uri_ref.query is not None\n                or uri_ref.fragment is not None):\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    def to_input_type(x):\n        if x is None:\n            return None\n        elif not is_string and not isinstance(x, six.binary_type):\n            return x.encode('utf-8')\n        return x\n\n    return Url(\n        scheme=to_input_type(uri_ref.scheme),\n        auth=to_input_type(uri_ref.userinfo),\n        host=to_input_type(uri_ref.host),\n        port=int(uri_ref.port) if uri_ref.port is not None else None,\n        path=to_input_type(path),\n        query=to_input_type(uri_ref.query),\n        fragment=to_input_type(uri_ref.fragment)\n    )\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def qemu_img_info(path, format=None):\n    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"\n    # TODO(mikal): this code should not be referring to a libvirt specific\n    # flag.\n    # NOTE(sirp): The config option import must go here to avoid an import\n    # cycle\n    CONF.import_opt('images_type', 'nova.virt.libvirt.imagebackend',\n                    group='libvirt')\n    if not os.path.exists(path) and CONF.libvirt.images_type != 'rbd':\n        msg = (_(\"Path does not exist %(path)s\") % {'path': path})\n        raise exception.InvalidDiskInfo(reason=msg)\n\n    cmd = ('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info', path)\n    if format is not None:\n        cmd = cmd + ('-f', format)\n    try:\n        out, err = utils.execute(*cmd)\n    except processutils.ProcessExecutionError as exp:\n        msg = (_(\"qemu-img failed to execute on %(path)s : %(exp)s\") %\n                {'path': path, 'exp': exp})\n        raise exception.InvalidDiskInfo(reason=msg)\n\n    if not out:\n        msg = (_(\"Failed to run qemu-img info on %(path)s : %(error)s\") %\n               {'path': path, 'error': err})\n        raise exception.InvalidDiskInfo(reason=msg)\n\n    return imageutils.QemuImgInfo(out)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def render_POST(self, request):\n        send_cors(request)\n\n        if self.require_auth:\n            authV2(self.sydent, request)\n\n        args = get_args(request, ('email', 'client_secret', 'send_attempt'))\n\n        email = args['email']\n        sendAttempt = args['send_attempt']\n        clientSecret = args['client_secret']\n\n        if not is_valid_client_secret(clientSecret):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid client_secret provided'\n            }\n\n        ipaddress = self.sydent.ip_from_request(request)\n        brand = self.sydent.brand_from_request(request)\n\n        nextLink = None\n        if 'next_link' in args and not args['next_link'].startswith(\"file:///\"):\n            nextLink = args['next_link']\n\n        try:\n            sid = self.sydent.validators.email.requestToken(\n                email, clientSecret, sendAttempt, nextLink, ipaddress=ipaddress, brand=brand,\n            )\n            resp = {'sid': str(sid)}\n        except EmailAddressException:\n            request.setResponseCode(400)\n            resp = {'errcode': 'M_INVALID_EMAIL', 'error': 'Invalid email address'}\n        except EmailSendException:\n            request.setResponseCode(500)\n            resp = {'errcode': 'M_EMAIL_SEND_ERROR', 'error': 'Failed to send email'}\n\n        return resp\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_part_end(self) -> None:\n        message = (MultiPartMessage.PART_END, b\"\")\n        self.messages.append(message)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def response_for_exception(request, exc):\n    if isinstance(exc, Http404):\n        if settings.DEBUG:\n            response = debug.technical_404_response(request, exc)\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 404, exc\n            )\n\n    elif isinstance(exc, PermissionDenied):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 403, exc\n        )\n        log_response(\n            \"Forbidden (Permission denied): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, MultiPartParserError):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 400, exc\n        )\n        log_response(\n            \"Bad request (Unable to parse request body): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, BadRequest):\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n        log_response(\n            \"%s: %s\",\n            str(exc),\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n    elif isinstance(exc, SuspiciousOperation):\n        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):\n            # POST data can't be accessed again, otherwise the original\n            # exception would be raised.\n            request._mark_post_parse_error()\n\n        # The request logger receives events for any problematic request\n        # The security logger receives events for all SuspiciousOperations\n        security_logger = logging.getLogger(\n            \"django.security.%s\" % exc.__class__.__name__\n        )\n        security_logger.error(\n            str(exc),\n            extra={\"status_code\": 400, \"request\": request},\n        )\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n\n    else:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(\n            request, get_resolver(get_urlconf()), sys.exc_info()\n        )\n        log_response(\n            \"%s: %s\",\n            response.reason_phrase,\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    # Force a TemplateResponse to be rendered.\n    if not getattr(response, \"is_rendered\", True) and callable(\n        getattr(response, \"render\", None)\n    ):\n        response = response.render()\n\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def execute(self, image_id):\n        \"\"\"Create temp file into store and return path to it\n\n        :param image_id: Glance Image ID\n        \"\"\"\n        # NOTE(flaper87): We've decided to use a separate `work_dir` for\n        # this task - and tasks coming after this one - as a way to expect\n        # users to configure a local store for pre-import works on the image\n        # to happen.\n        #\n        # While using any path should be \"technically\" fine, it's not what\n        # we recommend as the best solution. For more details on this, please\n        # refer to the comment in the `_ImportToStore.execute` method.\n        data = script_utils.get_image_data_iter(self.uri)\n\n        path = self.store.add(image_id, data, 0, context=None)[0]\n\n        try:\n            # NOTE(flaper87): Consider moving this code to a common\n            # place that other tasks can consume as well.\n            stdout, stderr = putils.trycmd('qemu-img', 'info',\n                                           '--output=json', path,\n                                           log_errors=putils.LOG_ALL_ERRORS)\n        except OSError as exc:\n            with excutils.save_and_reraise_exception():\n                exc_message = encodeutils.exception_to_unicode(exc)\n                msg = _LE('Failed to execute security checks on the image '\n                          '%(task_id)s: %(exc)s')\n                LOG.error(msg, {'task_id': self.task_id, 'exc': exc_message})\n\n        metadata = json.loads(stdout)\n\n        backing_file = metadata.get('backing-filename')\n        if backing_file is not None:\n            msg = _(\"File %(path)s has invalid backing file \"\n                    \"%(bfile)s, aborting.\") % {'path': path,\n                                               'bfile': backing_file}\n            raise RuntimeError(msg)\n\n        return path\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *z = NULL, *pminus1;\n    int ret = -1;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        goto err;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    pminus1 = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    if (z == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        ERR_raise(ERR_LIB_DH, DH_R_NO_PRIVATE_VALUE);\n        goto err;\n    }\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      dh->lock, dh->params.p, ctx);\n        BN_set_flags(dh->priv_key, BN_FLG_CONSTTIME);\n        if (!mont)\n            goto err;\n    }\n\n    /* (Step 1) Z = pub_key^priv_key mod p */\n    if (!dh->meth->bn_mod_exp(dh, z, pub_key, dh->priv_key, dh->params.p, ctx,\n                              mont)) {\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* (Step 2) Error if z <= 1 or z = p - 1 */\n    if (BN_copy(pminus1, dh->params.p) == NULL\n        || !BN_sub_word(pminus1, 1)\n        || BN_cmp(z, BN_value_one()) <= 0\n        || BN_cmp(z, pminus1) == 0) {\n        ERR_raise(ERR_LIB_DH, DH_R_INVALID_SECRET);\n        goto err;\n    }\n\n    /* return the padded key, i.e. same number of bytes as the modulus */\n    ret = BN_bn2binpad(z, key, BN_num_bytes(dh->params.p));\n err:\n    BN_clear(z); /* (Step 2) destroy intermediate values */\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def validate_value(self, value):\n        if not is_list_like(value):\n            self.invalidate_value(\n                value,\n                msg=\"must be list-like object such as array or tuple\",\n            )\n\n        if len(value) != len(self.encoders):\n            self.invalidate_value(\n                value,\n                exc=ValueOutOfBounds,\n                msg=\"value has {} items when {} were expected\".format(\n                    len(value),\n                    len(self.encoders),\n                ),\n            )\n\n        for item, encoder in zip(value, self.encoders):\n            try:\n                encoder.validate_value(item)\n            except AttributeError:\n                encoder(item)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def qemu_img_info(path, run_as_root=True):\n    \"\"\"Return a object containing the parsed output from qemu-img info.\"\"\"\n    cmd = ('env', 'LC_ALL=C', 'qemu-img', 'info', path)\n    if os.name == 'nt':\n        cmd = cmd[2:]\n    out, _err = utils.execute(*cmd, run_as_root=run_as_root)\n    return imageutils.QemuImgInfo(out)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_contents_from_bundle(bundle: ZipFile) -> Dict[str, str]:\n    return {\n        remove_root(file_name): bundle.read(file_name).decode()\n        for file_name in bundle.namelist()\n        if is_valid_config(file_name)\n    }\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def to_python(self, value):\n        value = super().to_python(value)\n        if self.max_length is not None and len(value) > self.max_length:\n            # Normalization can increase the string length (e.g.\n            # \"\ufb00\" -> \"ff\", \"\u00bd\" -> \"1\u20442\") but cannot reduce it, so there is no\n            # point in normalizing invalid data. Moreover, Unicode\n            # normalization is very slow on Windows and can be a DoS attack\n            # vector.\n            return value\n        return unicodedata.normalize(\"NFKC\", value)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def get_available_name(self, name):\n        \"\"\"\n        Returns a filename that's free on the target storage system, and\n        available for new content to be written to.\n        \"\"\"\n        dir_name, file_name = os.path.split(name)\n        file_root, file_ext = os.path.splitext(file_name)\n        # If the filename already exists, add an underscore and a random 7\n        # character alphanumeric string (before the file extension, if one\n        # exists) to the filename until the generated filename doesn't exist.\n        while self.exists(name):\n            # file_ext includes the dot.\n            name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, get_random_string(7), file_ext))\n\n        return name\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        >>> parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        >>> parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        >>> parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    is_string = not isinstance(url, six.binary_type)\n\n    # RFC 3986 doesn't like URLs that have a host but don't start\n    # with a scheme and we support URLs like that so we need to\n    # detect that problem and add an empty scheme indication.\n    # We don't get hurt on path-only URLs here as it's stripped\n    # off and given an empty scheme anyways.\n    if not SCHEME_REGEX.search(url):\n        url = \"//\" + url\n\n    def idna_encode(name):\n        if name and any([ord(x) > 128 for x in name]):\n            try:\n                import idna\n            except ImportError:\n                raise LocationParseError(\"Unable to parse URL without the 'idna' module\")\n            try:\n                return idna.encode(name.lower(), strict=True, std3_rules=True)\n            except idna.IDNAError:\n                raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)\n        return name\n\n    try:\n        split_iri = misc.IRI_MATCHER.match(compat.to_str(url)).groupdict()\n        iri_ref = rfc3986.IRIReference(\n            split_iri['scheme'], split_iri['authority'],\n            _encode_invalid_chars(split_iri['path'], PATH_CHARS),\n            _encode_invalid_chars(split_iri['query'], QUERY_CHARS),\n            _encode_invalid_chars(split_iri['fragment'], FRAGMENT_CHARS)\n        )\n        has_authority = iri_ref.authority is not None\n        uri_ref = iri_ref.encode(idna_encoder=idna_encode)\n    except (ValueError, RFC3986Exception):\n        return six.raise_from(LocationParseError(url), None)\n\n    # rfc3986 strips the authority if it's invalid\n    if has_authority and uri_ref.authority is None:\n        raise LocationParseError(url)\n\n    # Only normalize schemes we understand to not break http+unix\n    # or other schemes that don't follow RFC 3986.\n    if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:\n        uri_ref = uri_ref.normalize()\n\n    # Validate all URIReference components and ensure that all\n    # components that were set before are still set after\n    # normalization has completed.\n    validator = Validator()\n    try:\n        validator.check_validity_of(\n            *validator.COMPONENT_NAMES\n        ).validate(uri_ref)\n    except ValidationError:\n        return six.raise_from(LocationParseError(url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    path = uri_ref.path\n    if not path:\n        if (uri_ref.query is not None\n                or uri_ref.fragment is not None):\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    def to_input_type(x):\n        if x is None:\n            return None\n        elif not is_string and not isinstance(x, six.binary_type):\n            return x.encode('utf-8')\n        return x\n\n    return Url(\n        scheme=to_input_type(uri_ref.scheme),\n        auth=to_input_type(uri_ref.userinfo),\n        host=to_input_type(uri_ref.host),\n        port=int(uri_ref.port) if uri_ref.port is not None else None,\n        path=to_input_type(path),\n        query=to_input_type(uri_ref.query),\n        fragment=to_input_type(uri_ref.fragment)\n    )\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def qemu_img_info(path, format=None):\n    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"\n    # TODO(mikal): this code should not be referring to a libvirt specific\n    # flag.\n    # NOTE(sirp): The config option import must go here to avoid an import\n    # cycle\n    CONF.import_opt('images_type', 'nova.virt.libvirt.imagebackend',\n                    group='libvirt')\n    if not os.path.exists(path) and CONF.libvirt.images_type != 'rbd':\n        msg = (_(\"Path does not exist %(path)s\") % {'path': path})\n        raise exception.InvalidDiskInfo(reason=msg)\n\n    cmd = ('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info', path)\n    if format is not None:\n        cmd = cmd + ('-f', format)\n    try:\n        if QEMU_IMG_LIMITS is not None:\n            out, err = utils.execute(*cmd, prlimit=QEMU_IMG_LIMITS)\n        else:\n            out, err = utils.execute(*cmd)\n    except processutils.ProcessExecutionError as exp:\n        msg = (_(\"qemu-img failed to execute on %(path)s : %(exp)s\") %\n                {'path': path, 'exp': exp})\n        raise exception.InvalidDiskInfo(reason=msg)\n\n    if not out:\n        msg = (_(\"Failed to run qemu-img info on %(path)s : %(error)s\") %\n               {'path': path, 'error': err})\n        raise exception.InvalidDiskInfo(reason=msg)\n\n    return imageutils.QemuImgInfo(out)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def render_POST(self, request):\n        send_cors(request)\n\n        if self.require_auth:\n            authV2(self.sydent, request)\n\n        args = get_args(request, ('email', 'client_secret', 'send_attempt'))\n\n        email = args['email']\n        sendAttempt = args['send_attempt']\n        clientSecret = args['client_secret']\n\n        if not is_valid_client_secret(clientSecret):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid client_secret provided'\n            }\n\n        if not (0 < len(email) <= MAX_EMAIL_ADDRESS_LENGTH):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid email provided'\n            }\n\n        ipaddress = self.sydent.ip_from_request(request)\n        brand = self.sydent.brand_from_request(request)\n\n        nextLink = None\n        if 'next_link' in args and not args['next_link'].startswith(\"file:///\"):\n            nextLink = args['next_link']\n\n        try:\n            sid = self.sydent.validators.email.requestToken(\n                email, clientSecret, sendAttempt, nextLink, ipaddress=ipaddress, brand=brand,\n            )\n            resp = {'sid': str(sid)}\n        except EmailAddressException:\n            request.setResponseCode(400)\n            resp = {'errcode': 'M_INVALID_EMAIL', 'error': 'Invalid email address'}\n        except EmailSendException:\n            request.setResponseCode(500)\n            resp = {'errcode': 'M_EMAIL_SEND_ERROR', 'error': 'Failed to send email'}\n\n        return resp\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    verify_svg(file_contents)\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_part_end(self) -> None:\n        if self._current_part.file is None:\n            self.items.append(\n                (\n                    self._current_part.field_name,\n                    _user_safe_decode(self._current_part.data, self._charset),\n                )\n            )\n        else:\n            self._file_parts_to_finish.append(self._current_part)\n            # The file can be added to the items right now even though it's not\n            # finished yet, because it will be finished in the `parse()` method, before\n            # self.items is used in the return value.\n            self.items.append((self._current_part.field_name, self._current_part.file))\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def response_for_exception(request, exc):\n    if isinstance(exc, Http404):\n        if settings.DEBUG:\n            response = debug.technical_404_response(request, exc)\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 404, exc\n            )\n\n    elif isinstance(exc, PermissionDenied):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 403, exc\n        )\n        log_response(\n            \"Forbidden (Permission denied): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, MultiPartParserError):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 400, exc\n        )\n        log_response(\n            \"Bad request (Unable to parse request body): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, BadRequest):\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n        log_response(\n            \"%s: %s\",\n            str(exc),\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n    elif isinstance(exc, SuspiciousOperation):\n        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent, TooManyFilesSent)):\n            # POST data can't be accessed again, otherwise the original\n            # exception would be raised.\n            request._mark_post_parse_error()\n\n        # The request logger receives events for any problematic request\n        # The security logger receives events for all SuspiciousOperations\n        security_logger = logging.getLogger(\n            \"django.security.%s\" % exc.__class__.__name__\n        )\n        security_logger.error(\n            str(exc),\n            extra={\"status_code\": 400, \"request\": request},\n        )\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n\n    else:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(\n            request, get_resolver(get_urlconf()), sys.exc_info()\n        )\n        log_response(\n            \"%s: %s\",\n            response.reason_phrase,\n            request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    # Force a TemplateResponse to be rendered.\n    if not getattr(response, \"is_rendered\", True) and callable(\n        getattr(response, \"render\", None)\n    ):\n        response = response.render()\n\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def execute(self, image_id):\n        \"\"\"Create temp file into store and return path to it\n\n        :param image_id: Glance Image ID\n        \"\"\"\n        # NOTE(flaper87): We've decided to use a separate `work_dir` for\n        # this task - and tasks coming after this one - as a way to expect\n        # users to configure a local store for pre-import works on the image\n        # to happen.\n        #\n        # While using any path should be \"technically\" fine, it's not what\n        # we recommend as the best solution. For more details on this, please\n        # refer to the comment in the `_ImportToStore.execute` method.\n        data = script_utils.get_image_data_iter(self.uri)\n\n        path = self.store.add(image_id, data, 0, context=None)[0]\n\n        try:\n            # NOTE(flaper87): Consider moving this code to a common\n            # place that other tasks can consume as well.\n            stdout, stderr = putils.trycmd('qemu-img', 'info',\n                                           '--output=json', path,\n                                           prlimit=utils.QEMU_IMG_PROC_LIMITS,\n                                           log_errors=putils.LOG_ALL_ERRORS)\n        except OSError as exc:\n            with excutils.save_and_reraise_exception():\n                exc_message = encodeutils.exception_to_unicode(exc)\n                msg = _LE('Failed to execute security checks on the image '\n                          '%(task_id)s: %(exc)s')\n                LOG.error(msg, {'task_id': self.task_id, 'exc': exc_message})\n\n        metadata = json.loads(stdout)\n\n        backing_file = metadata.get('backing-filename')\n        if backing_file is not None:\n            msg = _(\"File %(path)s has invalid backing file \"\n                    \"%(bfile)s, aborting.\") % {'path': path,\n                                               'bfile': backing_file}\n            raise RuntimeError(msg)\n\n        return path\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *z = NULL, *pminus1;\n    int ret = -1;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        goto err;\n    }\n\n    if (dh->params.q != NULL\n        && BN_num_bits(dh->params.q) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_Q_TOO_LARGE);\n        goto err;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    pminus1 = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    if (z == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        ERR_raise(ERR_LIB_DH, DH_R_NO_PRIVATE_VALUE);\n        goto err;\n    }\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      dh->lock, dh->params.p, ctx);\n        BN_set_flags(dh->priv_key, BN_FLG_CONSTTIME);\n        if (!mont)\n            goto err;\n    }\n\n    /* (Step 1) Z = pub_key^priv_key mod p */\n    if (!dh->meth->bn_mod_exp(dh, z, pub_key, dh->priv_key, dh->params.p, ctx,\n                              mont)) {\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* (Step 2) Error if z <= 1 or z = p - 1 */\n    if (BN_copy(pminus1, dh->params.p) == NULL\n        || !BN_sub_word(pminus1, 1)\n        || BN_cmp(z, BN_value_one()) <= 0\n        || BN_cmp(z, pminus1) == 0) {\n        ERR_raise(ERR_LIB_DH, DH_R_INVALID_SECRET);\n        goto err;\n    }\n\n    /* return the padded key, i.e. same number of bytes as the modulus */\n    ret = BN_bn2binpad(z, key, BN_num_bytes(dh->params.p));\n err:\n    BN_clear(z); /* (Step 2) destroy intermediate values */\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def validate_value(self, value):\n        if not is_list_like(value):\n            self.invalidate_value(\n                value,\n                msg=\"must be list-like object such as array or tuple\",\n            )\n\n        if len(value) == 0:\n            self.invalidate_value(\n                value,\n                msg='Zero-sized tuple types \"()\" are not supported.',\n            )\n\n        if len(value) != len(self.encoders):\n            self.invalidate_value(\n                value,\n                exc=ValueOutOfBounds,\n                msg=\"value has {} items when {} were expected\".format(\n                    len(value),\n                    len(self.encoders),\n                ),\n            )\n\n        for item, encoder in zip(value, self.encoders):\n            try:\n                encoder.validate_value(item)\n            except AttributeError:\n                encoder(item)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def qemu_img_info(path, run_as_root=True):\n    \"\"\"Return a object containing the parsed output from qemu-img info.\"\"\"\n    cmd = ('env', 'LC_ALL=C', 'qemu-img', 'info', path)\n    if os.name == 'nt':\n        cmd = cmd[2:]\n    out, _err = utils.execute(*cmd, run_as_root=run_as_root,\n                              prlimit=QEMU_IMG_LIMITS)\n    return imageutils.QemuImgInfo(out)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_contents_from_bundle(bundle: ZipFile) -> Dict[str, str]:\n    check_is_safe_zip(bundle)\n    return {\n        remove_root(file_name): bundle.read(file_name).decode()\n        for file_name in bundle.namelist()\n        if is_valid_config(file_name)\n    }\n"}, {"role": "assistant", "content": "False"}]}
