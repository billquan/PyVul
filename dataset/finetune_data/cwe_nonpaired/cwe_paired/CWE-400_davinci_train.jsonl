{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_headers_finished(self) -> None:\n        message = (MultiPartMessage.HEADERS_FINISHED, b\"\")\n        self.messages.append(message)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_part_begin(self) -> None:\n        message = (MultiPartMessage.PART_BEGIN, b\"\")\n        self.messages.append(message)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getbbox(\n        self,\n        text,\n        mode=\"\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        anchor=None,\n    ):\n        \"\"\"\n        Returns bounding box (in pixels) of given text relative to given anchor\n        when rendered in font with provided direction, features, and language.\n\n        Use :py:meth:`getlength()` to get the offset of following text with\n        1/64 pixel precision. The bounding box includes extra margins for\n        some fonts, e.g. italics or accents.\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :param stroke_width: The width of the text stroke.\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left.\n                        See :ref:`text-anchors` for valid values.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n        \"\"\"\n        size, offset = self.font.getsize(\n            text, mode, direction, features, language, anchor\n        )\n        left, top = offset[0] - stroke_width, offset[1] - stroke_width\n        width, height = size[0] + 2 * stroke_width, size[1] + 2 * stroke_width\n        return left, top, left + width, top + height\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def run(argv: List[str]) -> None:\n    args = parse_command_line(argv)\n    remarshal(\n        args.input,\n        args.output,\n        args.input_format,\n        args.output_format,\n        json_indent=args.json_indent,\n        ordered=args.ordered,\n        stringify=args.stringify,\n        unwrap=args.unwrap,\n        wrap=args.wrap,\n        yaml_options=args.yaml_options,\n    )\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n{\n    return ossl_ffc_validate_public_key(&dh->params, pub_key, ret);\n}\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def get_available_name(self, name):\n        \"\"\"\n        Returns a filename that's free on the target storage system, and\n        available for new content to be written to.\n        \"\"\"\n        dir_name, file_name = os.path.split(name)\n        file_root, file_ext = os.path.splitext(file_name)\n        # If the filename already exists, add an underscore and a number (before\n        # the file extension, if one exists) to the filename until the generated\n        # filename doesn't exist.\n        count = itertools.count(1)\n        while self.exists(name):\n            # file_ext includes the dot.\n            name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, next(count), file_ext))\n\n        return name\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def render_POST(self, request):\n        send_cors(request)\n\n        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))\n        medium = args[\"medium\"]\n        address = args[\"address\"]\n        roomId = args[\"room_id\"]\n        sender = args[\"sender\"]\n\n        verified_sender = None\n        if self.require_auth:\n            account = authV2(self.sydent, request)\n            verified_sender = sender\n            if account.userId != sender:\n                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")\n\n        globalAssocStore = GlobalAssociationStore(self.sydent)\n        mxid = globalAssocStore.getMxid(medium, address)\n        if mxid:\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_THREEPID_IN_USE\",\n                \"error\": \"Binding already known\",\n                \"mxid\": mxid,\n            }\n\n        if medium != \"email\":\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_UNRECOGNIZED\",\n                \"error\": \"Didn't understand medium '%s'\" % (medium,),\n            }\n\n        token = self._randomString(128)\n\n        tokenStore = JoinTokenStore(self.sydent)\n\n        ephemeralPrivateKey = nacl.signing.SigningKey.generate()\n        ephemeralPublicKey = ephemeralPrivateKey.verify_key\n\n        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)\n        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)\n\n        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)\n        tokenStore.storeToken(medium, address, roomId, sender, token)\n\n        # Variables to substitute in the template.\n        substitutions = {}\n        # Include all arguments sent via the request.\n        for k, v in args.items():\n            if isinstance(v, string_types):\n                substitutions[k] = v\n        substitutions[\"token\"] = token\n\n        # Substitutions that the template requires, but are optional to provide\n        # to the API.\n        extra_substitutions = [\n            'sender_display_name',\n            'token',\n            'room_name',\n            'bracketed_room_name',\n            'room_avatar_url',\n            'sender_avatar_url',\n            'guest_user_id',\n            'guest_access_token',\n        ]\n        for k in extra_substitutions:\n            substitutions.setdefault(k, '')\n\n        substitutions[\"bracketed_verified_sender\"] = \"\"\n        if verified_sender:\n            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)\n\n        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64\n        if substitutions[\"room_name\"] != '':\n            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]\n\n        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location\n        if 'org.matrix.web_client_location' in substitutions:\n            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")\n\n        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')\n        substitutions[\"subject_header_value\"] = subject_header.encode()\n\n        brand = self.sydent.brand_from_request(request)\n        templateFile = self.sydent.get_branded_template(\n            brand,\n            \"invite_template.eml\",\n            ('email', 'email.invite_template'),\n        )\n\n        sendEmail(self.sydent, templateFile, address, substitutions)\n\n        pubKey = self.sydent.keyring.ed25519.verify_key\n        pubKeyBase64 = encode_base64(pubKey.encode())\n\n        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)\n\n        keysToReturn = []\n        keysToReturn.append({\n            \"public_key\": pubKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",\n        })\n        keysToReturn.append({\n            \"public_key\": ephemeralPublicKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",\n        })\n\n        resp = {\n            \"token\": token,\n            \"public_key\": pubKeyBase64,\n            \"public_keys\": keysToReturn,\n            \"display_name\": self.redact_email_address(address),\n        }\n\n        return resp\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n#ifndef FIPS_MODULE\n    unsigned l;\n#endif\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_secure_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else {\n        priv_key = dh->priv_key;\n    }\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else {\n        pub_key = dh->pub_key;\n    }\n    if (generate_new_key) {\n        /* Is it an approved safe prime ?*/\n        if (DH_get_nid(dh) != NID_undef) {\n            int max_strength =\n                    ossl_ifc_ffc_compute_security_bits(BN_num_bits(dh->params.p));\n\n            if (dh->params.q == NULL\n                || dh->length > BN_num_bits(dh->params.q))\n                goto err;\n            /* dh->length = maximum bit length of generated private key */\n            if (!ossl_ffc_generate_private_key(ctx, &dh->params, dh->length,\n                                               max_strength, priv_key))\n                goto err;\n        } else {\n#ifdef FIPS_MODULE\n            if (dh->params.q == NULL)\n                goto err;\n#else\n            if (dh->params.q == NULL) {\n                /* secret exponent length, must satisfy 2^(l-1) <= p */\n                if (dh->length != 0\n                    && dh->length >= BN_num_bits(dh->params.p))\n                    goto err;\n                l = dh->length ? dh->length : BN_num_bits(dh->params.p) - 1;\n                if (!BN_priv_rand_ex(priv_key, l, BN_RAND_TOP_ONE,\n                                     BN_RAND_BOTTOM_ANY, 0, ctx))\n                    goto err;\n                /*\n                 * We handle just one known case where g is a quadratic non-residue:\n                 * for g = 2: p % 8 == 3\n                 */\n                if (BN_is_word(dh->params.g, DH_GENERATOR_2)\n                    && !BN_is_bit_set(dh->params.p, 2)) {\n                    /* clear bit 0, since it won't be a secret anyway */\n                    if (!BN_clear_bit(priv_key, 0))\n                        goto err;\n                }\n            } else\n#endif\n            {\n                /* Do a partial check for invalid p, q, g */\n                if (!ossl_ffc_params_simple_validate(dh->libctx, &dh->params,\n                                                     FFC_PARAM_TYPE_DH, NULL))\n                    goto err;\n                /*\n                 * For FFC FIPS 186-4 keygen\n                 * security strength s = 112,\n                 * Max Private key size N = len(q)\n                 */\n                if (!ossl_ffc_generate_private_key(ctx, &dh->params,\n                                                   BN_num_bits(dh->params.q),\n                                                   MIN_STRENGTH,\n                                                   priv_key))\n                    goto err;\n            }\n        }\n    }\n\n    if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))\n        goto err;\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    dh->dirty_cnt++;\n    ok = 1;\n err:\n    if (ok != 1)\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n\n    if (pub_key != dh->pub_key)\n        BN_free(pub_key);\n    if (priv_key != dh->priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getlength(self, text, mode=\"\", direction=None, features=None, language=None):\n        \"\"\"\n        Returns length (in pixels with 1/64 precision) of given text when rendered\n        in font with provided direction, features, and language.\n\n        This is the amount by which following text should be offset.\n        Text bounding box may extend past the length in some fonts,\n        e.g. when using italics or accents.\n\n        The result is returned as a float; it is a whole number if using basic layout.\n\n        Note that the sum of two lengths may not equal the length of a concatenated\n        string due to kerning. If you need to adjust for kerning, include the following\n        character and subtract its length.\n\n        For example, instead of ::\n\n          hello = font.getlength(\"Hello\")\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # not adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # may fail\n\n        use ::\n\n          hello = font.getlength(\"HelloW\") - font.getlength(\"W\")  # adjusted for kerning\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # True\n\n        or disable kerning with (requires libraqm) ::\n\n          hello = draw.textlength(\"Hello\", font, features=[\"-kern\"])\n          world = draw.textlength(\"World\", font, features=[\"-kern\"])\n          hello_world = hello + world  # kerning is disabled, no need to adjust\n          assert hello_world == draw.textlength(\"HelloWorld\", font, features=[\"-kern\"])\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to measure.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :return: Width for horizontal, height for vertical text.\n        \"\"\"\n        return self.font.getlength(text, mode, direction, features, language) / 64\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def encode(self, types: Iterable[TypeStr], args: Iterable[Any]) -> bytes:\n        \"\"\"\n        Encodes the python values in ``args`` as a sequence of binary values of\n        the ABI types in ``types`` via the head-tail mechanism.\n\n        :param types: A list or tuple of string representations of the ABI types\n            that will be used for encoding e.g.  ``('uint256', 'bytes[]',\n            '(int,int)')``\n        :param args: A list or tuple of python values to be encoded.\n\n        :returns: The head-tail encoded binary representation of the python\n            values in ``args`` as values of the ABI types in ``types``.\n        \"\"\"\n        validate_list_like_param(types, \"types\")\n        validate_list_like_param(args, \"args\")\n\n        encoders = [self._registry.get_encoder(type_str) for type_str in types]\n\n        encoder = TupleEncoder(encoders=encoders)\n\n        return encoder(args)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def serve(self):\n        \"\"\"\n        Serve client connections.\n\n        Begin listening for client connections, spinning off new KmipSessions\n        as connections are handled. Set up signal handling to shutdown\n        connection service as needed.\n        \"\"\"\n        self._socket.listen(5)\n\n        def _signal_handler(signal_number, stack_frame):\n            self._is_serving = False\n\n            # Python3.5+ silently ignores SIGINT and retries system calls if\n            # the signal handler does not raise an exception. Explicitly\n            # detect SIGINT and raise a KeyboardInterrupt exception to regain\n            # old functionality.\n            if signal_number == signal.SIGINT:\n                raise KeyboardInterrupt(\"SIGINT received\")\n\n        signal.signal(signal.SIGINT, _signal_handler)\n        signal.signal(signal.SIGTERM, _signal_handler)\n\n        self._logger.info(\"Starting connection service...\")\n\n        while self._is_serving:\n            try:\n                connection, address = self._socket.accept()\n            except socket.error as e:\n                self._logger.warning(\n                    \"Error detected while establishing new connection.\"\n                )\n                self._logger.exception(e)\n            except KeyboardInterrupt:\n                self._logger.warning(\"Interrupting connection service.\")\n                self._is_serving = False\n                break\n            except Exception as e:\n                self._logger.warning(\n                    \"Error detected while establishing new connection.\"\n                )\n                self._logger.exception(e)\n            else:\n                self._setup_connection_handler(connection, address)\n\n        self._logger.info(\"Stopping connection service.\")\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getmask(self, text, mode=\"\", *args, **kwargs):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :return: An internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module.\n        \"\"\"\n        return self.font.getmask(text, mode)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def __init__(self, handler):\n        self.handler = handler\n        self.protocol_version = None\n        self.support_legacy_versions = True\n        self.supported_protocols = []\n        self.origin_checker = None\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def debug_decisions(self, text):\n        \"\"\"\n        Classifies candidate periods as sentence breaks, yielding a dict for\n        each that may be used to understand why the decision was made.\n\n        See format_debug_decision() to help make this output readable.\n        \"\"\"\n\n        for match in self._lang_vars.period_context_re().finditer(text):\n            decision_text = match.group() + match.group(\"after_tok\")\n            tokens = self._tokenize_words(decision_text)\n            tokens = list(self._annotate_first_pass(tokens))\n            while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars):\n                tokens.pop(0)\n            yield {\n                \"period_index\": match.end() - 1,\n                \"text\": decision_text,\n                \"type1\": tokens[0].type,\n                \"type2\": tokens[1].type,\n                \"type1_in_abbrs\": bool(tokens[0].abbr),\n                \"type1_is_initial\": bool(tokens[0].is_initial),\n                \"type2_is_sent_starter\": tokens[1].type_no_sentperiod\n                in self._params.sent_starters,\n                \"type2_ortho_heuristic\": self._ortho_heuristic(tokens[1]),\n                \"type2_ortho_contexts\": set(\n                    self._params._debug_ortho_context(tokens[1].type_no_sentperiod)\n                ),\n                \"collocation\": (\n                    tokens[0].type_no_sentperiod,\n                    tokens[1].type_no_sentperiod,\n                )\n                in self._params.collocations,\n                \"reason\": self._second_pass_annotation(tokens[0], tokens[1])\n                or REASON_DEFAULT_DECISION,\n                \"break_decision\": tokens[0].sentbreak,\n            }\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _load_post_and_files(self):\n        \"\"\"Populate self._post and self._files if the content-type is a form type\"\"\"\n        if self.method != \"POST\":\n            self._post, self._files = (\n                QueryDict(encoding=self._encoding),\n                MultiValueDict(),\n            )\n            return\n        if self._read_started and not hasattr(self, \"_body\"):\n            self._mark_post_parse_error()\n            return\n\n        if self.content_type == \"multipart/form-data\":\n            if hasattr(self, \"_body\"):\n                # Use already read data\n                data = BytesIO(self._body)\n            else:\n                data = self\n            try:\n                self._post, self._files = self.parse_file_upload(self.META, data)\n            except MultiPartParserError:\n                # An error occurred while parsing POST data. Since when\n                # formatting the error the request handler might access\n                # self.POST, set self._post and self._file to prevent\n                # attempts to parse POST data again.\n                self._mark_post_parse_error()\n                raise\n        elif self.content_type == \"application/x-www-form-urlencoded\":\n            self._post, self._files = (\n                QueryDict(self.body, encoding=self._encoding),\n                MultiValueDict(),\n            )\n        else:\n            self._post, self._files = (\n                QueryDict(encoding=self._encoding),\n                MultiValueDict(),\n            )\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_default_span_name(environ):\n    \"\"\"\n    Default span name is the HTTP method and URL path, or just the method.\n    https://github.com/open-telemetry/opentelemetry-specification/pull/3165\n    https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/#name\n\n    Args:\n        environ: The WSGI environ object.\n    Returns:\n        The span name.\n    \"\"\"\n    method = environ.get(\"REQUEST_METHOD\", \"\").strip()\n    path = environ.get(\"PATH_INFO\", \"\").strip()\n    if method and path:\n        return f\"{method} {path}\"\n    return method\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_contents_from_bundle(bundle: ZipFile) -> dict[str, str]:\n    return {\n        remove_root(file_name): bundle.read(file_name).decode()\n        for file_name in bundle.namelist()\n        if is_valid_config(file_name)\n    }\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *z = NULL, *pminus1;\n    int ret = -1;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        goto err;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    pminus1 = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    if (z == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        ERR_raise(ERR_LIB_DH, DH_R_NO_PRIVATE_VALUE);\n        goto err;\n    }\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      dh->lock, dh->params.p, ctx);\n        BN_set_flags(dh->priv_key, BN_FLG_CONSTTIME);\n        if (!mont)\n            goto err;\n    }\n\n    /* (Step 1) Z = pub_key^priv_key mod p */\n    if (!dh->meth->bn_mod_exp(dh, z, pub_key, dh->priv_key, dh->params.p, ctx,\n                              mont)) {\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* (Step 2) Error if z <= 1 or z = p - 1 */\n    if (BN_copy(pminus1, dh->params.p) == NULL\n        || !BN_sub_word(pminus1, 1)\n        || BN_cmp(z, BN_value_one()) <= 0\n        || BN_cmp(z, pminus1) == 0) {\n        ERR_raise(ERR_LIB_DH, DH_R_INVALID_SECRET);\n        goto err;\n    }\n\n    /* return the padded key, i.e. same number of bytes as the modulus */\n    ret = BN_bn2binpad(z, key, BN_num_bytes(dh->params.p));\n err:\n    BN_clear(z); /* (Step 2) destroy intermediate values */\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _construct_forms(self):\n        # instantiate all the forms and put them in self.forms\n        self.forms = []\n        for i in xrange(self.total_form_count()):\n            self.forms.append(self._construct_form(i))\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_header_end(self) -> None:\n        message = (MultiPartMessage.HEADER_END, b\"\")\n        self.messages.append(message)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def handle_message(self, stream, payload):\n        payload = self.decode_payload(payload)\n        # XXX: Is header really needed?\n        reply = yield self.message_handler(payload)\n        self.stream.send(self.encode_payload(reply))\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "        def getvalue(self):\n            data = b\"\".join(self.data)\n            if not self.opcode & 8 and self.decompressor:\n                data = self.decompressor.decompress(data + b'\\x00\\x00\\xff\\xff')\n            if self.decoder:\n                data = self.decoder.decode(data, self.finished)\n            return data\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    async def parse(self) -> FormData:\n        # Parse the Content-Type header to get the multipart boundary.\n        _, params = parse_options_header(self.headers[\"Content-Type\"])\n        charset = params.get(b\"charset\", \"utf-8\")\n        if type(charset) == bytes:\n            charset = charset.decode(\"latin-1\")\n        try:\n            boundary = params[b\"boundary\"]\n        except KeyError:\n            raise MultiPartException(\"Missing boundary in multipart.\")\n\n        # Callbacks dictionary.\n        callbacks = {\n            \"on_part_begin\": self.on_part_begin,\n            \"on_part_data\": self.on_part_data,\n            \"on_part_end\": self.on_part_end,\n            \"on_header_field\": self.on_header_field,\n            \"on_header_value\": self.on_header_value,\n            \"on_header_end\": self.on_header_end,\n            \"on_headers_finished\": self.on_headers_finished,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.MultipartParser(boundary, callbacks)\n        header_field = b\"\"\n        header_value = b\"\"\n        content_disposition = None\n        field_name = \"\"\n        data = b\"\"\n        file: typing.Optional[UploadFile] = None\n\n        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []\n        item_headers: typing.List[typing.Tuple[bytes, bytes]] = []\n\n        # Feed the parser with data from the request.\n        async for chunk in self.stream:\n            parser.write(chunk)\n            messages = list(self.messages)\n            self.messages.clear()\n            for message_type, message_bytes in messages:\n                if message_type == MultiPartMessage.PART_BEGIN:\n                    content_disposition = None\n                    data = b\"\"\n                    item_headers = []\n                elif message_type == MultiPartMessage.HEADER_FIELD:\n                    header_field += message_bytes\n                elif message_type == MultiPartMessage.HEADER_VALUE:\n                    header_value += message_bytes\n                elif message_type == MultiPartMessage.HEADER_END:\n                    field = header_field.lower()\n                    if field == b\"content-disposition\":\n                        content_disposition = header_value\n                    item_headers.append((field, header_value))\n                    header_field = b\"\"\n                    header_value = b\"\"\n                elif message_type == MultiPartMessage.HEADERS_FINISHED:\n                    disposition, options = parse_options_header(content_disposition)\n                    try:\n                        field_name = _user_safe_decode(options[b\"name\"], charset)\n                    except KeyError:\n                        raise MultiPartException(\n                            'The Content-Disposition header field \"name\" must be '\n                            \"provided.\"\n                        )\n                    if b\"filename\" in options:\n                        filename = _user_safe_decode(options[b\"filename\"], charset)\n                        tempfile = SpooledTemporaryFile(max_size=self.max_file_size)\n                        file = UploadFile(\n                            file=tempfile,  # type: ignore[arg-type]\n                            size=0,\n                            filename=filename,\n                            headers=Headers(raw=item_headers),\n                        )\n                    else:\n                        file = None\n                elif message_type == MultiPartMessage.PART_DATA:\n                    if file is None:\n                        data += message_bytes\n                    else:\n                        await file.write(message_bytes)\n                elif message_type == MultiPartMessage.PART_END:\n                    if file is None:\n                        items.append((field_name, _user_safe_decode(data, charset)))\n                    else:\n                        await file.seek(0)\n                        items.append((field_name, file))\n\n        parser.finalize()\n        return FormData(items)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def response_for_exception(request, exc):\n    if isinstance(exc, Http404):\n        if settings.DEBUG:\n            response = debug.technical_404_response(request, exc)\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 404, exc\n            )\n\n    elif isinstance(exc, PermissionDenied):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 403, exc\n        )\n        log_response(\n            \"Forbidden (Permission denied): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    elif isinstance(exc, MultiPartParserError):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 400, exc\n        )\n        log_response(\n            \"Bad request (Unable to parse request body): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    elif isinstance(exc, BadRequest):\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n        log_response(\n            \"%s: %s\",\n            str(exc),\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n    elif isinstance(exc, SuspiciousOperation):\n        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):\n            # POST data can't be accessed again, otherwise the original\n            # exception would be raised.\n            request._mark_post_parse_error()\n\n        # The request logger receives events for any problematic request\n        # The security logger receives events for all SuspiciousOperations\n        security_logger = logging.getLogger(\n            \"django.security.%s\" % exc.__class__.__name__\n        )\n        security_logger.error(\n            str(exc),\n            exc_info=exc,\n            extra={\"status_code\": 400, \"request\": request},\n        )\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n\n    else:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(\n            request, get_resolver(get_urlconf()), sys.exc_info()\n        )\n        log_response(\n            \"%s: %s\",\n            response.reason_phrase,\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    # Force a TemplateResponse to be rendered.\n    if not getattr(response, \"is_rendered\", True) and callable(\n        getattr(response, \"render\", None)\n    ):\n        response = response.render()\n\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _handle_hybi_request(self, environ):\n        if 'eventlet.input' in environ:\n            sock = environ['eventlet.input'].get_socket()\n        elif 'gunicorn.socket' in environ:\n            sock = environ['gunicorn.socket']\n        else:\n            raise Exception('No eventlet.input or gunicorn.socket present in environ.')\n\n        hybi_version = environ['HTTP_SEC_WEBSOCKET_VERSION']\n        if hybi_version not in ('8', '13', ):\n            raise BadRequest(status='426 Upgrade Required',\n                             headers=[('Sec-WebSocket-Version', '8, 13')])\n        self.protocol_version = int(hybi_version)\n        if 'HTTP_SEC_WEBSOCKET_KEY' not in environ:\n            # That's bad.\n            raise BadRequest()\n        origin = environ.get(\n            'HTTP_ORIGIN',\n            (environ.get('HTTP_SEC_WEBSOCKET_ORIGIN', '')\n             if self.protocol_version <= 8 else ''))\n        if self.origin_checker is not None:\n            if not self.origin_checker(environ.get('HTTP_HOST'), origin):\n                raise BadRequest(status='403 Forbidden')\n        protocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL', None)\n        negotiated_protocol = None\n        if protocols:\n            for p in (i.strip() for i in protocols.split(',')):\n                if p in self.supported_protocols:\n                    negotiated_protocol = p\n                    break\n\n        key = environ['HTTP_SEC_WEBSOCKET_KEY']\n        response = base64.b64encode(sha1(six.b(key) + PROTOCOL_GUID).digest())\n        handshake_reply = [b\"HTTP/1.1 101 Switching Protocols\",\n                           b\"Upgrade: websocket\",\n                           b\"Connection: Upgrade\",\n                           b\"Sec-WebSocket-Accept: \" + response]\n        if negotiated_protocol:\n            handshake_reply.append(b\"Sec-WebSocket-Protocol: \" + six.b(negotiated_protocol))\n\n        parsed_extensions = {}\n        extensions = self._parse_extension_header(environ.get(\"HTTP_SEC_WEBSOCKET_EXTENSIONS\"))\n\n        deflate = self._negotiate_permessage_deflate(extensions)\n        if deflate is not None:\n            parsed_extensions[\"permessage-deflate\"] = deflate\n\n        formatted_ext = self._format_extension_header(parsed_extensions)\n        if formatted_ext is not None:\n            handshake_reply.append(b\"Sec-WebSocket-Extensions: \" + formatted_ext)\n\n        sock.sendall(b'\\r\\n'.join(handshake_reply) + b'\\r\\n\\r\\n')\n        return RFC6455WebSocket(sock, environ, self.protocol_version,\n                                protocol=negotiated_protocol,\n                                extensions=parsed_extensions)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def handle_message(self, stream, payload):\n        payload = self.decode_payload(payload)\n        # XXX: Is header really needed?\n        reply = yield self.message_handler(payload)\n        self.stream.send(self.encode_payload(reply))\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def is_valid_client_secret(client_secret):\n    \"\"\"Validate that a given string matches the client_secret regex defined by the spec\n\n    :param client_secret: The client_secret to validate\n    :type client_secret: str\n\n    :return: Whether the client_secret is valid\n    :rtype: bool\n    \"\"\"\n    return client_secret_regex.match(client_secret) is not None\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def collect_request_attributes(environ):\n    \"\"\"Collects HTTP request attributes from the PEP3333-conforming\n    WSGI environ and returns a dictionary to be used as span creation attributes.\n    \"\"\"\n\n    result = {\n        SpanAttributes.HTTP_METHOD: environ.get(\"REQUEST_METHOD\"),\n        SpanAttributes.HTTP_SERVER_NAME: environ.get(\"SERVER_NAME\"),\n        SpanAttributes.HTTP_SCHEME: environ.get(\"wsgi.url_scheme\"),\n    }\n\n    host_port = environ.get(\"SERVER_PORT\")\n    if host_port is not None and not host_port == \"\":\n        result.update({SpanAttributes.NET_HOST_PORT: int(host_port)})\n\n    setifnotnone(result, SpanAttributes.HTTP_HOST, environ.get(\"HTTP_HOST\"))\n    target = environ.get(\"RAW_URI\")\n    if target is None:  # Note: `\"\" or None is None`\n        target = environ.get(\"REQUEST_URI\")\n    if target is not None:\n        result[SpanAttributes.HTTP_TARGET] = target\n    else:\n        result[SpanAttributes.HTTP_URL] = remove_url_credentials(\n            wsgiref_util.request_uri(environ)\n        )\n\n    remote_addr = environ.get(\"REMOTE_ADDR\")\n    if remote_addr:\n        result[SpanAttributes.NET_PEER_IP] = remote_addr\n    remote_host = environ.get(\"REMOTE_HOST\")\n    if remote_host and remote_host != remote_addr:\n        result[SpanAttributes.NET_PEER_NAME] = remote_host\n\n    user_agent = environ.get(\"HTTP_USER_AGENT\")\n    if user_agent is not None and len(user_agent) > 0:\n        result[SpanAttributes.HTTP_USER_AGENT] = user_agent\n\n    setifnotnone(\n        result, SpanAttributes.NET_PEER_PORT, environ.get(\"REMOTE_PORT\")\n    )\n    flavor = environ.get(\"SERVER_PROTOCOL\", \"\")\n    if flavor.upper().startswith(_HTTP_VERSION_PREFIX):\n        flavor = flavor[len(_HTTP_VERSION_PREFIX) :]\n    if flavor:\n        result[SpanAttributes.HTTP_FLAVOR] = flavor\n\n    return result\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n#ifndef FIPS_MODULE\n    unsigned l;\n#endif\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_secure_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else {\n        priv_key = dh->priv_key;\n    }\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else {\n        pub_key = dh->pub_key;\n    }\n    if (generate_new_key) {\n        /* Is it an approved safe prime ?*/\n        if (DH_get_nid(dh) != NID_undef) {\n            int max_strength =\n                    ossl_ifc_ffc_compute_security_bits(BN_num_bits(dh->params.p));\n\n            if (dh->params.q == NULL\n                || dh->length > BN_num_bits(dh->params.q))\n                goto err;\n            /* dh->length = maximum bit length of generated private key */\n            if (!ossl_ffc_generate_private_key(ctx, &dh->params, dh->length,\n                                               max_strength, priv_key))\n                goto err;\n        } else {\n#ifdef FIPS_MODULE\n            if (dh->params.q == NULL)\n                goto err;\n#else\n            if (dh->params.q == NULL) {\n                /* secret exponent length, must satisfy 2^(l-1) <= p */\n                if (dh->length != 0\n                    && dh->length >= BN_num_bits(dh->params.p))\n                    goto err;\n                l = dh->length ? dh->length : BN_num_bits(dh->params.p) - 1;\n                if (!BN_priv_rand_ex(priv_key, l, BN_RAND_TOP_ONE,\n                                     BN_RAND_BOTTOM_ANY, 0, ctx))\n                    goto err;\n                /*\n                 * We handle just one known case where g is a quadratic non-residue:\n                 * for g = 2: p % 8 == 3\n                 */\n                if (BN_is_word(dh->params.g, DH_GENERATOR_2)\n                    && !BN_is_bit_set(dh->params.p, 2)) {\n                    /* clear bit 0, since it won't be a secret anyway */\n                    if (!BN_clear_bit(priv_key, 0))\n                        goto err;\n                }\n            } else\n#endif\n            {\n                /* Do a partial check for invalid p, q, g */\n                if (!ossl_ffc_params_simple_validate(dh->libctx, &dh->params,\n                                                     FFC_PARAM_TYPE_DH, NULL))\n                    goto err;\n                /*\n                 * For FFC FIPS 186-4 keygen\n                 * security strength s = 112,\n                 * Max Private key size N = len(q)\n                 */\n                if (!ossl_ffc_generate_private_key(ctx, &dh->params,\n                                                   BN_num_bits(dh->params.q),\n                                                   MIN_STRENGTH,\n                                                   priv_key))\n                    goto err;\n            }\n        }\n    }\n\n    if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))\n        goto err;\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    dh->dirty_cnt++;\n    ok = 1;\n err:\n    if (ok != 1)\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n\n    if (pub_key != dh->pub_key)\n        BN_free(pub_key);\n    if (priv_key != dh->priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def send(self, anyway=False, prefetch=False):\n        \"\"\"Sends the request. Returns True of successful, False if not.\n        If there was an HTTPError during transmission,\n        self.response.status_code will contain the HTTPError code.\n\n        Once a request is successfully sent, `sent` will equal True.\n\n        :param anyway: If True, request will be sent, even if it has\n        already been sent.\n        \"\"\"\n\n        # Build the URL\n        url = self.full_url\n\n        # Logging\n        if self.config.get('verbose'):\n            self.config.get('verbose').write('%s   %s   %s\\n' % (\n                datetime.now().isoformat(), self.method, url\n            ))\n\n        # Nottin' on you.\n        body = None\n        content_type = None\n\n        # Multi-part file uploads.\n        if self.files:\n            if not isinstance(self.data, str):\n\n                try:\n                    fields = self.data.copy()\n                except AttributeError:\n                    fields = dict(self.data)\n\n                for (k, v) in list(self.files.items()):\n                    # support for explicit filename\n                    if isinstance(v, (tuple, list)):\n                        fn, fp = v\n                    else:\n                        fn = guess_filename(v) or k\n                        fp = v\n                    fields.update({k: (fn, fp.read())})\n\n                (body, content_type) = encode_multipart_formdata(fields)\n            else:\n                pass\n                # TODO: Conflict?\n        else:\n            if self.data:\n\n                body = self._enc_data\n                if isinstance(self.data, str):\n                    content_type = None\n                else:\n                    content_type = 'application/x-www-form-urlencoded'\n\n        # Add content-type if it wasn't explicitly provided.\n        if (content_type) and (not 'content-type' in self.headers):\n            self.headers['Content-Type'] = content_type\n\n        # Use .netrc auth if none was provided.\n        if not self.auth and self.config.get('trust_env'):\n            self.auth = get_netrc_auth(url)\n\n        if self.auth:\n            if isinstance(self.auth, tuple) and len(self.auth) == 2:\n                # special-case basic HTTP auth\n                self.auth = HTTPBasicAuth(*self.auth)\n\n            # Allow auth to make its changes.\n            r = self.auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n        _p = urlparse(url)\n        proxy = self.proxies.get(_p.scheme)\n\n        if proxy:\n            conn = poolmanager.proxy_from_url(proxy)\n            _proxy = urlparse(proxy)\n            if '@' in _proxy.netloc:\n                auth, url = _proxy.netloc.split('@', 1)\n                self.proxy_auth = HTTPProxyAuth(*auth.split(':', 1))\n                r = self.proxy_auth(self)\n                self.__dict__.update(r.__dict__)\n        else:\n            # Check to see if keep_alive is allowed.\n            if self.config.get('keep_alive'):\n                conn = self._poolmanager.connection_from_url(url)\n            else:\n                conn = connectionpool.connection_from_url(url)\n\n        if url.startswith('https') and self.verify:\n\n            cert_loc = None\n\n            # Allow self-specified cert location.\n            if self.verify is not True:\n                cert_loc = self.verify\n\n            # Look for configuration.\n            if not cert_loc and self.config.get('trust_env'):\n                cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n\n            # Curl compatiblity.\n            if not cert_loc and self.config.get('trust_env'):\n                cert_loc = os.environ.get('CURL_CA_BUNDLE')\n\n            # Use the awesome certifi list.\n            if not cert_loc:\n                cert_loc = __import__('certifi').where()\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n            conn.ca_certs = cert_loc\n        else:\n            conn.cert_reqs = 'CERT_NONE'\n            conn.ca_certs = None\n\n        if self.cert and self.verify:\n            if len(self.cert) == 2:\n                conn.cert_file = self.cert[0]\n                conn.key_file = self.cert[1]\n            else:\n                conn.cert_file = self.cert\n\n        if not self.sent or anyway:\n\n            if self.cookies:\n\n                # Skip if 'cookie' header is explicitly set.\n                if 'cookie' not in self.headers:\n\n                    # Simple cookie with our dict.\n                    c = SimpleCookie()\n                    for (k, v) in list(self.cookies.items()):\n                        c[k] = v\n\n                    # Turn it into a header.\n                    cookie_header = c.output(header='', sep='; ').strip()\n\n                    # Attach Cookie header to request.\n                    self.headers['Cookie'] = cookie_header\n\n            # Pre-request hook.\n            r = dispatch_hook('pre_request', self.hooks, self)\n            self.__dict__.update(r.__dict__)\n\n            try:\n                # The inner try .. except re-raises certain exceptions as\n                # internal exception types; the outer suppresses exceptions\n                # when safe mode is set.\n                try:\n                    # Send the request.\n                    r = conn.urlopen(\n                        method=self.method,\n                        url=self.path_url,\n                        body=body,\n                        headers=self.headers,\n                        redirect=False,\n                        assert_same_host=False,\n                        preload_content=False,\n                        decode_content=False,\n                        retries=self.config.get('max_retries', 0),\n                        timeout=self.timeout,\n                    )\n                    self.sent = True\n\n                except MaxRetryError as e:\n                    raise ConnectionError(e)\n\n                except (_SSLError, _HTTPError) as e:\n                    if self.verify and isinstance(e, _SSLError):\n                        raise SSLError(e)\n\n                    raise Timeout('Request timed out.')\n\n            except RequestException as e:\n                if self.config.get('safe_mode', False):\n                    # In safe mode, catch the exception and attach it to\n                    # a blank urllib3.HTTPResponse object.\n                    r = HTTPResponse()\n                    r.error = e\n                else:\n                    raise\n\n            self._build_response(r)\n\n            # Response manipulation hook.\n            self.response = dispatch_hook('response', self.hooks, self.response)\n\n            # Post-request hook.\n            r = dispatch_hook('post_request', self.hooks, self)\n            self.__dict__.update(r.__dict__)\n\n            # If prefetch is True, mark content as consumed.\n            if prefetch:\n                # Save the response.\n                self.response.content\n\n            if self.config.get('danger_mode'):\n                self.response.raise_for_status()\n\n            return self.sent\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _load_post_and_files(self):\n        \"\"\"Populate self._post and self._files if the content-type is a form type\"\"\"\n        if self.method != 'POST':\n            self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()\n            return\n        if self._read_started and not hasattr(self, '_body'):\n            self._mark_post_parse_error()\n            return\n\n        if self.content_type == 'multipart/form-data':\n            if hasattr(self, '_body'):\n                # Use already read data\n                data = BytesIO(self._body)\n            else:\n                data = self\n            try:\n                self._post, self._files = self.parse_file_upload(self.META, data)\n            except MultiPartParserError:\n                # An error occurred while parsing POST data. Since when\n                # formatting the error the request handler might access\n                # self.POST, set self._post and self._file to prevent\n                # attempts to parse POST data again.\n                self._mark_post_parse_error()\n                raise\n        elif self.content_type == 'application/x-www-form-urlencoded':\n            self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()\n        else:\n            self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_part_data(self, data: bytes, start: int, end: int) -> None:\n        message = (MultiPartMessage.PART_DATA, data[start:end])\n        self.messages.append(message)\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *z = NULL, *pminus1;\n    int ret = -1;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        goto err;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    pminus1 = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    if (z == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        ERR_raise(ERR_LIB_DH, DH_R_NO_PRIVATE_VALUE);\n        goto err;\n    }\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      dh->lock, dh->params.p, ctx);\n        BN_set_flags(dh->priv_key, BN_FLG_CONSTTIME);\n        if (!mont)\n            goto err;\n    }\n\n    /* (Step 1) Z = pub_key^priv_key mod p */\n    if (!dh->meth->bn_mod_exp(dh, z, pub_key, dh->priv_key, dh->params.p, ctx,\n                              mont)) {\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* (Step 2) Error if z <= 1 or z = p - 1 */\n    if (BN_copy(pminus1, dh->params.p) == NULL\n        || !BN_sub_word(pminus1, 1)\n        || BN_cmp(z, BN_value_one()) <= 0\n        || BN_cmp(z, pminus1) == 0) {\n        ERR_raise(ERR_LIB_DH, DH_R_INVALID_SECRET);\n        goto err;\n    }\n\n    /* return the padded key, i.e. same number of bytes as the modulus */\n    ret = BN_bn2binpad(z, key, BN_num_bytes(dh->params.p));\n err:\n    BN_clear(z); /* (Step 2) destroy intermediate values */\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def parse(self):\n        \"\"\"\n        Parse the POST data and break it into a FILES MultiValueDict and a POST\n        MultiValueDict.\n\n        Return a tuple containing the POST and FILES dictionary, respectively.\n        \"\"\"\n        from django.http import QueryDict\n\n        encoding = self._encoding\n        handlers = self._upload_handlers\n\n        # HTTP spec says that Content-Length >= 0 is valid\n        # handling content-length == 0 before continuing\n        if self._content_length == 0:\n            return QueryDict(encoding=self._encoding), MultiValueDict()\n\n        # See if any of the handlers take care of the parsing.\n        # This allows overriding everything if need be.\n        for handler in handlers:\n            result = handler.handle_raw_input(\n                self._input_data,\n                self._meta,\n                self._content_length,\n                self._boundary,\n                encoding,\n            )\n            # Check to see if it was handled\n            if result is not None:\n                return result[0], result[1]\n\n        # Create the data structures to be used later.\n        self._post = QueryDict(mutable=True)\n        self._files = MultiValueDict()\n\n        # Instantiate the parser and stream:\n        stream = LazyStream(ChunkIter(self._input_data, self._chunk_size))\n\n        # Whether or not to signal a file-completion at the beginning of the loop.\n        old_field_name = None\n        counters = [0] * len(handlers)\n\n        # Number of bytes that have been read.\n        num_bytes_read = 0\n        # To count the number of keys in the request.\n        num_post_keys = 0\n        # To limit the amount of data read from the request.\n        read_size = None\n        # Whether a file upload is finished.\n        uploaded_file = True\n\n        try:\n            for item_type, meta_data, field_stream in Parser(stream, self._boundary):\n                if old_field_name:\n                    # We run this at the beginning of the next loop\n                    # since we cannot be sure a file is complete until\n                    # we hit the next boundary/part of the multipart content.\n                    self.handle_file_complete(old_field_name, counters)\n                    old_field_name = None\n                    uploaded_file = True\n\n                try:\n                    disposition = meta_data[\"content-disposition\"][1]\n                    field_name = disposition[\"name\"].strip()\n                except (KeyError, IndexError, AttributeError):\n                    continue\n\n                transfer_encoding = meta_data.get(\"content-transfer-encoding\")\n                if transfer_encoding is not None:\n                    transfer_encoding = transfer_encoding[0].strip()\n                field_name = force_str(field_name, encoding, errors=\"replace\")\n\n                if item_type == FIELD:\n                    # Avoid storing more than DATA_UPLOAD_MAX_NUMBER_FIELDS.\n                    num_post_keys += 1\n                    if (\n                        settings.DATA_UPLOAD_MAX_NUMBER_FIELDS is not None\n                        and settings.DATA_UPLOAD_MAX_NUMBER_FIELDS < num_post_keys\n                    ):\n                        raise TooManyFieldsSent(\n                            \"The number of GET/POST parameters exceeded \"\n                            \"settings.DATA_UPLOAD_MAX_NUMBER_FIELDS.\"\n                        )\n\n                    # Avoid reading more than DATA_UPLOAD_MAX_MEMORY_SIZE.\n                    if settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None:\n                        read_size = (\n                            settings.DATA_UPLOAD_MAX_MEMORY_SIZE - num_bytes_read\n                        )\n\n                    # This is a post field, we can just set it in the post\n                    if transfer_encoding == \"base64\":\n                        raw_data = field_stream.read(size=read_size)\n                        num_bytes_read += len(raw_data)\n                        try:\n                            data = base64.b64decode(raw_data)\n                        except binascii.Error:\n                            data = raw_data\n                    else:\n                        data = field_stream.read(size=read_size)\n                        num_bytes_read += len(data)\n\n                    # Add two here to make the check consistent with the\n                    # x-www-form-urlencoded check that includes '&='.\n                    num_bytes_read += len(field_name) + 2\n                    if (\n                        settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None\n                        and num_bytes_read > settings.DATA_UPLOAD_MAX_MEMORY_SIZE\n                    ):\n                        raise RequestDataTooBig(\n                            \"Request body exceeded \"\n                            \"settings.DATA_UPLOAD_MAX_MEMORY_SIZE.\"\n                        )\n\n                    self._post.appendlist(\n                        field_name, force_str(data, encoding, errors=\"replace\")\n                    )\n                elif item_type == FILE:\n                    # This is a file, use the handler...\n                    file_name = disposition.get(\"filename\")\n                    if file_name:\n                        file_name = force_str(file_name, encoding, errors=\"replace\")\n                        file_name = self.sanitize_file_name(file_name)\n                    if not file_name:\n                        continue\n\n                    content_type, content_type_extra = meta_data.get(\n                        \"content-type\", (\"\", {})\n                    )\n                    content_type = content_type.strip()\n                    charset = content_type_extra.get(\"charset\")\n\n                    try:\n                        content_length = int(meta_data.get(\"content-length\")[0])\n                    except (IndexError, TypeError, ValueError):\n                        content_length = None\n\n                    counters = [0] * len(handlers)\n                    uploaded_file = False\n                    try:\n                        for handler in handlers:\n                            try:\n                                handler.new_file(\n                                    field_name,\n                                    file_name,\n                                    content_type,\n                                    content_length,\n                                    charset,\n                                    content_type_extra,\n                                )\n                            except StopFutureHandlers:\n                                break\n\n                        for chunk in field_stream:\n                            if transfer_encoding == \"base64\":\n                                # We only special-case base64 transfer encoding\n                                # We should always decode base64 chunks by\n                                # multiple of 4, ignoring whitespace.\n\n                                stripped_chunk = b\"\".join(chunk.split())\n\n                                remaining = len(stripped_chunk) % 4\n                                while remaining != 0:\n                                    over_chunk = field_stream.read(4 - remaining)\n                                    if not over_chunk:\n                                        break\n                                    stripped_chunk += b\"\".join(over_chunk.split())\n                                    remaining = len(stripped_chunk) % 4\n\n                                try:\n                                    chunk = base64.b64decode(stripped_chunk)\n                                except Exception as exc:\n                                    # Since this is only a chunk, any error is\n                                    # an unfixable error.\n                                    raise MultiPartParserError(\n                                        \"Could not decode base64 data.\"\n                                    ) from exc\n\n                            for i, handler in enumerate(handlers):\n                                chunk_length = len(chunk)\n                                chunk = handler.receive_data_chunk(chunk, counters[i])\n                                counters[i] += chunk_length\n                                if chunk is None:\n                                    # Don't continue if the chunk received by\n                                    # the handler is None.\n                                    break\n\n                    except SkipFile:\n                        self._close_files()\n                        # Just use up the rest of this file...\n                        exhaust(field_stream)\n                    else:\n                        # Handle file upload completions on next iteration.\n                        old_field_name = field_name\n                else:\n                    # If this is neither a FIELD or a FILE, just exhaust the stream.\n                    exhaust(stream)\n        except StopUpload as e:\n            self._close_files()\n            if not e.connection_reset:\n                exhaust(self._input_data)\n        else:\n            if not uploaded_file:\n                for handler in handlers:\n                    handler.upload_interrupted()\n            # Make sure that the request data is all fed\n            exhaust(self._input_data)\n\n        # Signal that the upload has completed.\n        # any() shortcircuits if a handler's upload_complete() returns a value.\n        any(handler.upload_complete() for handler in handlers)\n        self._post._mutable = False\n        return self._post, self._files\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve(request, path, document_root=None, show_indexes=False):\n    \"\"\"\n    Serve static files below a given point in the directory structure.\n\n    To use, put a URL pattern such as::\n\n        (r'^(?P<path>.*)$', 'django.views.static.serve', {'document_root' : '/path/to/my/files/'})\n\n    in your URLconf. You must provide the ``document_root`` param. You may\n    also set ``show_indexes`` to ``True`` if you'd like to serve a basic index\n    of the directory.  This index view will use the template hardcoded below,\n    but if you'd like to override it, you can create a template called\n    ``static/directory_index.html``.\n    \"\"\"\n    path = posixpath.normpath(urllib.unquote(path))\n    path = path.lstrip('/')\n    newpath = ''\n    for part in path.split('/'):\n        if not part:\n            # Strip empty path components.\n            continue\n        drive, part = os.path.splitdrive(part)\n        head, part = os.path.split(part)\n        if part in (os.curdir, os.pardir):\n            # Strip '.' and '..' in path.\n            continue\n        newpath = os.path.join(newpath, part).replace('\\\\', '/')\n    if newpath and path != newpath:\n        return HttpResponseRedirect(newpath)\n    fullpath = os.path.join(document_root, newpath)\n    if os.path.isdir(fullpath):\n        if show_indexes:\n            return directory_index(newpath, fullpath)\n        raise Http404(_(u\"Directory indexes are not allowed here.\"))\n    if not os.path.exists(fullpath):\n        raise Http404(_(u'\"%(path)s\" does not exist') % {'path': fullpath})\n    # Respect the If-Modified-Since header.\n    statobj = os.stat(fullpath)\n    mimetype, encoding = mimetypes.guess_type(fullpath)\n    mimetype = mimetype or 'application/octet-stream'\n    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                              statobj.st_mtime, statobj.st_size):\n        return HttpResponseNotModified(mimetype=mimetype)\n    with open(fullpath, 'rb') as f:\n        response = HttpResponse(f.read(), mimetype=mimetype)\n    response[\"Last-Modified\"] = http_date(statobj.st_mtime)\n    if stat.S_ISREG(statobj.st_mode):\n        response[\"Content-Length\"] = statobj.st_size\n    if encoding:\n        response[\"Content-Encoding\"] = encoding\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def data_received(self, data):\n        self._buffer += data\n        # try to parse the incoming data\n        while self._buffer:\n            try:\n                buf = Buffer(self._buffer)\n                try:\n                    header = header_from_binary(buf)\n                except NotEnoughData:\n                    logger.debug('Not enough data while parsing header from client, waiting for more')\n                    return\n                if len(buf) < header.body_size:\n                    logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,\n                                 len(buf))\n                    return\n                # we have a complete message\n                self.messages.put_nowait((header, buf))\n                self._buffer = self._buffer[(header.header_size + header.body_size):]\n            except Exception:\n                logger.exception('Exception raised while parsing message from client')\n                return\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve(request, path, document_root=None, show_indexes=False):\n    \"\"\"\n    Serve static files below a given point in the directory structure.\n\n    To use, put a URL pattern such as::\n\n        (r'^(?P<path>.*)$', 'django.views.static.serve', {'document_root': '/path/to/my/files/'})\n\n    in your URLconf. You must provide the ``document_root`` param. You may\n    also set ``show_indexes`` to ``True`` if you'd like to serve a basic index\n    of the directory.  This index view will use the template hardcoded below,\n    but if you'd like to override it, you can create a template called\n    ``static/directory_index.html``.\n    \"\"\"\n    path = posixpath.normpath(unquote(path))\n    path = path.lstrip('/')\n    newpath = ''\n    for part in path.split('/'):\n        if not part:\n            # Strip empty path components.\n            continue\n        drive, part = os.path.splitdrive(part)\n        head, part = os.path.split(part)\n        if part in (os.curdir, os.pardir):\n            # Strip '.' and '..' in path.\n            continue\n        newpath = os.path.join(newpath, part).replace('\\\\', '/')\n    if newpath and path != newpath:\n        return HttpResponseRedirect(newpath)\n    fullpath = os.path.join(document_root, newpath)\n    if os.path.isdir(fullpath):\n        if show_indexes:\n            return directory_index(newpath, fullpath)\n        raise Http404(_(\"Directory indexes are not allowed here.\"))\n    if not os.path.exists(fullpath):\n        raise Http404(_('\"%(path)s\" does not exist') % {'path': fullpath})\n    # Respect the If-Modified-Since header.\n    statobj = os.stat(fullpath)\n    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                              statobj.st_mtime, statobj.st_size):\n        return HttpResponseNotModified()\n    content_type, encoding = mimetypes.guess_type(fullpath)\n    content_type = content_type or 'application/octet-stream'\n    response = StreamingHttpResponse(open(fullpath, 'rb'),\n                                     content_type=content_type)\n    response[\"Last-Modified\"] = http_date(statobj.st_mtime)\n    if stat.S_ISREG(statobj.st_mode):\n        response[\"Content-Length\"] = statobj.st_size\n    if encoding:\n        response[\"Content-Encoding\"] = encoding\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def remarshal(\n    input: Path | str,\n    output: Path | str,\n    input_format: str,\n    output_format: str,\n    *,\n    json_indent: Union[int, None] = None,\n    ordered: bool = True,\n    stringify: bool = False,\n    transform: Union[Callable[[Document], Document], None] = None,\n    unwrap: Union[str, None] = None,\n    wrap: Union[str, None] = None,\n    yaml_options: Dict[Any, Any] = {},\n) -> None:\n    input_file = None\n    output_file = None\n\n    try:\n        input_file = sys.stdin.buffer if input == \"-\" else Path(input).open(\"rb\")\n        output_file = sys.stdout.buffer if output == \"-\" else Path(output).open(\"wb\")\n\n        input_data = input_file.read()\n        if not isinstance(input_data, bytes):\n            msg = \"input_data must be bytes\"\n            raise TypeError(msg)\n\n        parsed = decode(input_format, input_data)\n\n        if unwrap is not None:\n            if not isinstance(parsed, Mapping):\n                msg = (\n                    f\"Top-level value of type '{type(parsed).__name__}' \"\n                    \"cannot be unwrapped\"\n                )\n                raise TypeError(msg)\n            parsed = parsed[unwrap]\n        if wrap is not None:\n            temp = {}\n            temp[wrap] = parsed\n            parsed = temp\n\n        if transform:\n            parsed = transform(parsed)\n\n        encoded = encode(\n            output_format,\n            parsed,\n            json_indent=json_indent,\n            ordered=ordered,\n            stringify=stringify,\n            yaml_options=yaml_options,\n        )\n\n        output_file.write(encoded)\n    finally:\n        if input_file is not None:\n            input_file.close()\n        if output != \"-\" and output_file is not None:\n            output_file.close()\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve(request, path, document_root=None, show_indexes=False):\n    \"\"\"\n    Serve static files below a given point in the directory structure.\n\n    To use, put a URL pattern such as::\n\n        (r'^(?P<path>.*)$', 'django.views.static.serve', {'document_root' : '/path/to/my/files/'})\n\n    in your URLconf. You must provide the ``document_root`` param. You may\n    also set ``show_indexes`` to ``True`` if you'd like to serve a basic index\n    of the directory.  This index view will use the template hardcoded below,\n    but if you'd like to override it, you can create a template called\n    ``static/directory_index.html``.\n    \"\"\"\n    path = posixpath.normpath(unquote(path))\n    path = path.lstrip('/')\n    newpath = ''\n    for part in path.split('/'):\n        if not part:\n            # Strip empty path components.\n            continue\n        drive, part = os.path.splitdrive(part)\n        head, part = os.path.split(part)\n        if part in (os.curdir, os.pardir):\n            # Strip '.' and '..' in path.\n            continue\n        newpath = os.path.join(newpath, part).replace('\\\\', '/')\n    if newpath and path != newpath:\n        return HttpResponseRedirect(newpath)\n    fullpath = os.path.join(document_root, newpath)\n    if os.path.isdir(fullpath):\n        if show_indexes:\n            return directory_index(newpath, fullpath)\n        raise Http404(_(\"Directory indexes are not allowed here.\"))\n    if not os.path.exists(fullpath):\n        raise Http404(_('\"%(path)s\" does not exist') % {'path': fullpath})\n    # Respect the If-Modified-Since header.\n    statobj = os.stat(fullpath)\n    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                              statobj.st_mtime, statobj.st_size):\n        return HttpResponseNotModified()\n    content_type, encoding = mimetypes.guess_type(fullpath)\n    content_type = content_type or 'application/octet-stream'\n    response = CompatibleStreamingHttpResponse(open(fullpath, 'rb'),\n                                               content_type=content_type)\n    response[\"Last-Modified\"] = http_date(statobj.st_mtime)\n    if stat.S_ISREG(statobj.st_mode):\n        response[\"Content-Length\"] = statobj.st_size\n    if encoding:\n        response[\"Content-Encoding\"] = encoding\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def execute(self, image_id, file_path):\n        \"\"\"Does the actual introspection\n\n        :param image_id: Glance image ID\n        :param file_path: Path to the file being introspected\n        \"\"\"\n\n        try:\n            stdout, stderr = putils.trycmd('qemu-img', 'info',\n                                           '--output=json', file_path,\n                                           log_errors=putils.LOG_ALL_ERRORS)\n        except OSError as exc:\n            # NOTE(flaper87): errno == 2 means the executable file\n            # was not found. For now, log an error and move forward\n            # until we have a better way to enable/disable optional\n            # tasks.\n            if exc.errno != 2:\n                with excutils.save_and_reraise_exception():\n                    exc_message = encodeutils.exception_to_unicode(exc)\n                    msg = _LE('Failed to execute introspection '\n                              '%(task_id)s: %(exc)s')\n                    LOG.error(msg, {'task_id': self.task_id,\n                                    'exc': exc_message})\n            return\n\n        if stderr:\n            raise RuntimeError(stderr)\n\n        metadata = json.loads(stdout)\n        new_image = self.image_repo.get(image_id)\n        new_image.virtual_size = metadata.get('virtual-size', 0)\n        new_image.disk_format = metadata.get('format')\n        self.image_repo.save(new_image)\n        LOG.debug(\"%(task_id)s: Introspection successful: %(file)s\",\n                  {'task_id': self.task_id, 'file': file_path})\n        return new_image\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def parse(self):\n        \"\"\"\n        Parse the POST data and break it into a FILES MultiValueDict and a POST\n        MultiValueDict.\n\n        Return a tuple containing the POST and FILES dictionary, respectively.\n        \"\"\"\n        from django.http import QueryDict\n\n        encoding = self._encoding\n        handlers = self._upload_handlers\n\n        # HTTP spec says that Content-Length >= 0 is valid\n        # handling content-length == 0 before continuing\n        if self._content_length == 0:\n            return QueryDict(encoding=self._encoding), MultiValueDict()\n\n        # See if any of the handlers take care of the parsing.\n        # This allows overriding everything if need be.\n        for handler in handlers:\n            result = handler.handle_raw_input(\n                self._input_data,\n                self._meta,\n                self._content_length,\n                self._boundary,\n                encoding,\n            )\n            # Check to see if it was handled\n            if result is not None:\n                return result[0], result[1]\n\n        # Create the data structures to be used later.\n        self._post = QueryDict(mutable=True)\n        self._files = MultiValueDict()\n\n        # Instantiate the parser and stream:\n        stream = LazyStream(ChunkIter(self._input_data, self._chunk_size))\n\n        # Whether or not to signal a file-completion at the beginning of the loop.\n        old_field_name = None\n        counters = [0] * len(handlers)\n\n        # Number of bytes that have been read.\n        num_bytes_read = 0\n        # To count the number of keys in the request.\n        num_post_keys = 0\n        # To limit the amount of data read from the request.\n        read_size = None\n        # Whether a file upload is finished.\n        uploaded_file = True\n\n        try:\n            for item_type, meta_data, field_stream in Parser(stream, self._boundary):\n                if old_field_name:\n                    # We run this at the beginning of the next loop\n                    # since we cannot be sure a file is complete until\n                    # we hit the next boundary/part of the multipart content.\n                    self.handle_file_complete(old_field_name, counters)\n                    old_field_name = None\n                    uploaded_file = True\n\n                try:\n                    disposition = meta_data[\"content-disposition\"][1]\n                    field_name = disposition[\"name\"].strip()\n                except (KeyError, IndexError, AttributeError):\n                    continue\n\n                transfer_encoding = meta_data.get(\"content-transfer-encoding\")\n                if transfer_encoding is not None:\n                    transfer_encoding = transfer_encoding[0].strip()\n                field_name = force_str(field_name, encoding, errors=\"replace\")\n\n                if item_type == FIELD:\n                    # Avoid storing more than DATA_UPLOAD_MAX_NUMBER_FIELDS.\n                    num_post_keys += 1\n                    if (\n                        settings.DATA_UPLOAD_MAX_NUMBER_FIELDS is not None\n                        and settings.DATA_UPLOAD_MAX_NUMBER_FIELDS < num_post_keys\n                    ):\n                        raise TooManyFieldsSent(\n                            \"The number of GET/POST parameters exceeded \"\n                            \"settings.DATA_UPLOAD_MAX_NUMBER_FIELDS.\"\n                        )\n\n                    # Avoid reading more than DATA_UPLOAD_MAX_MEMORY_SIZE.\n                    if settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None:\n                        read_size = (\n                            settings.DATA_UPLOAD_MAX_MEMORY_SIZE - num_bytes_read\n                        )\n\n                    # This is a post field, we can just set it in the post\n                    if transfer_encoding == \"base64\":\n                        raw_data = field_stream.read(size=read_size)\n                        num_bytes_read += len(raw_data)\n                        try:\n                            data = base64.b64decode(raw_data)\n                        except binascii.Error:\n                            data = raw_data\n                    else:\n                        data = field_stream.read(size=read_size)\n                        num_bytes_read += len(data)\n\n                    # Add two here to make the check consistent with the\n                    # x-www-form-urlencoded check that includes '&='.\n                    num_bytes_read += len(field_name) + 2\n                    if (\n                        settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None\n                        and num_bytes_read > settings.DATA_UPLOAD_MAX_MEMORY_SIZE\n                    ):\n                        raise RequestDataTooBig(\n                            \"Request body exceeded \"\n                            \"settings.DATA_UPLOAD_MAX_MEMORY_SIZE.\"\n                        )\n\n                    self._post.appendlist(\n                        field_name, force_str(data, encoding, errors=\"replace\")\n                    )\n                elif item_type == FILE:\n                    # This is a file, use the handler...\n                    file_name = disposition.get(\"filename\")\n                    if file_name:\n                        file_name = force_str(file_name, encoding, errors=\"replace\")\n                        file_name = self.sanitize_file_name(file_name)\n                    if not file_name:\n                        continue\n\n                    content_type, content_type_extra = meta_data.get(\n                        \"content-type\", (\"\", {})\n                    )\n                    content_type = content_type.strip()\n                    charset = content_type_extra.get(\"charset\")\n\n                    try:\n                        content_length = int(meta_data.get(\"content-length\")[0])\n                    except (IndexError, TypeError, ValueError):\n                        content_length = None\n\n                    counters = [0] * len(handlers)\n                    uploaded_file = False\n                    try:\n                        for handler in handlers:\n                            try:\n                                handler.new_file(\n                                    field_name,\n                                    file_name,\n                                    content_type,\n                                    content_length,\n                                    charset,\n                                    content_type_extra,\n                                )\n                            except StopFutureHandlers:\n                                break\n\n                        for chunk in field_stream:\n                            if transfer_encoding == \"base64\":\n                                # We only special-case base64 transfer encoding\n                                # We should always decode base64 chunks by\n                                # multiple of 4, ignoring whitespace.\n\n                                stripped_chunk = b\"\".join(chunk.split())\n\n                                remaining = len(stripped_chunk) % 4\n                                while remaining != 0:\n                                    over_chunk = field_stream.read(4 - remaining)\n                                    if not over_chunk:\n                                        break\n                                    stripped_chunk += b\"\".join(over_chunk.split())\n                                    remaining = len(stripped_chunk) % 4\n\n                                try:\n                                    chunk = base64.b64decode(stripped_chunk)\n                                except Exception as exc:\n                                    # Since this is only a chunk, any error is\n                                    # an unfixable error.\n                                    raise MultiPartParserError(\n                                        \"Could not decode base64 data.\"\n                                    ) from exc\n\n                            for i, handler in enumerate(handlers):\n                                chunk_length = len(chunk)\n                                chunk = handler.receive_data_chunk(chunk, counters[i])\n                                counters[i] += chunk_length\n                                if chunk is None:\n                                    # Don't continue if the chunk received by\n                                    # the handler is None.\n                                    break\n\n                    except SkipFile:\n                        self._close_files()\n                        # Just use up the rest of this file...\n                        exhaust(field_stream)\n                    else:\n                        # Handle file upload completions on next iteration.\n                        old_field_name = field_name\n                else:\n                    # If this is neither a FIELD or a FILE, just exhaust the stream.\n                    exhaust(stream)\n        except StopUpload as e:\n            self._close_files()\n            if not e.connection_reset:\n                exhaust(self._input_data)\n        else:\n            if not uploaded_file:\n                for handler in handlers:\n                    handler.upload_interrupted()\n            # Make sure that the request data is all fed\n            exhaust(self._input_data)\n\n        # Signal that the upload has completed.\n        # any() shortcircuits if a handler's upload_complete() returns a value.\n        any(handler.upload_complete() for handler in handlers)\n        self._post._mutable = False\n        return self._post, self._files\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _construct_forms(self):\n        # instantiate all the forms and put them in self.forms\n        self.forms = []\n        for i in xrange(self.total_form_count()):\n            self.forms.append(self._construct_form(i))\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def response_for_exception(request, exc):\n    if isinstance(exc, Http404):\n        if settings.DEBUG:\n            response = debug.technical_404_response(request, exc)\n        else:\n            response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)\n\n    elif isinstance(exc, PermissionDenied):\n        response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)\n        log_response(\n            'Forbidden (Permission denied): %s', request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, MultiPartParserError):\n        response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n        log_response(\n            'Bad request (Unable to parse request body): %s', request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, BadRequest):\n        if settings.DEBUG:\n            response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)\n        else:\n            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n        log_response(\n            '%s: %s', str(exc), request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n    elif isinstance(exc, SuspiciousOperation):\n        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):\n            # POST data can't be accessed again, otherwise the original\n            # exception would be raised.\n            request._mark_post_parse_error()\n\n        # The request logger receives events for any problematic request\n        # The security logger receives events for all SuspiciousOperations\n        security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)\n        security_logger.error(\n            str(exc),\n            extra={'status_code': 400, 'request': request},\n        )\n        if settings.DEBUG:\n            response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)\n        else:\n            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n\n    elif isinstance(exc, SystemExit):\n        # Allow sys.exit() to actually exit. See tickets #1023 and #4701\n        raise\n\n    else:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())\n        log_response(\n            '%s: %s', response.reason_phrase, request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    # Force a TemplateResponse to be rendered.\n    if not getattr(response, 'is_rendered', True) and callable(getattr(response, 'render', None)):\n        response = response.render()\n\n    return response\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n#ifndef FIPS_MODULE\n    unsigned l;\n#endif\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_secure_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else {\n        priv_key = dh->priv_key;\n    }\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else {\n        pub_key = dh->pub_key;\n    }\n    if (generate_new_key) {\n        /* Is it an approved safe prime ?*/\n        if (DH_get_nid(dh) != NID_undef) {\n            int max_strength =\n                    ossl_ifc_ffc_compute_security_bits(BN_num_bits(dh->params.p));\n\n            if (dh->params.q == NULL\n                || dh->length > BN_num_bits(dh->params.q))\n                goto err;\n            /* dh->length = maximum bit length of generated private key */\n            if (!ossl_ffc_generate_private_key(ctx, &dh->params, dh->length,\n                                               max_strength, priv_key))\n                goto err;\n        } else {\n#ifdef FIPS_MODULE\n            if (dh->params.q == NULL)\n                goto err;\n#else\n            if (dh->params.q == NULL) {\n                /* secret exponent length, must satisfy 2^(l-1) <= p */\n                if (dh->length != 0\n                    && dh->length >= BN_num_bits(dh->params.p))\n                    goto err;\n                l = dh->length ? dh->length : BN_num_bits(dh->params.p) - 1;\n                if (!BN_priv_rand_ex(priv_key, l, BN_RAND_TOP_ONE,\n                                     BN_RAND_BOTTOM_ANY, 0, ctx))\n                    goto err;\n                /*\n                 * We handle just one known case where g is a quadratic non-residue:\n                 * for g = 2: p % 8 == 3\n                 */\n                if (BN_is_word(dh->params.g, DH_GENERATOR_2)\n                    && !BN_is_bit_set(dh->params.p, 2)) {\n                    /* clear bit 0, since it won't be a secret anyway */\n                    if (!BN_clear_bit(priv_key, 0))\n                        goto err;\n                }\n            } else\n#endif\n            {\n                /* Do a partial check for invalid p, q, g */\n                if (!ossl_ffc_params_simple_validate(dh->libctx, &dh->params,\n                                                     FFC_PARAM_TYPE_DH, NULL))\n                    goto err;\n                /*\n                 * For FFC FIPS 186-4 keygen\n                 * security strength s = 112,\n                 * Max Private key size N = len(q)\n                 */\n                if (!ossl_ffc_generate_private_key(ctx, &dh->params,\n                                                   BN_num_bits(dh->params.q),\n                                                   MIN_STRENGTH,\n                                                   priv_key))\n                    goto err;\n            }\n        }\n    }\n\n    if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))\n        goto err;\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    dh->dirty_cnt++;\n    ok = 1;\n err:\n    if (ok != 1)\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n\n    if (pub_key != dh->pub_key)\n        BN_free(pub_key);\n    if (priv_key != dh->priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def parse_native_url(url):\n        \"\"\"\n        Support https://maker.ifttt.com/use/WEBHOOK_ID/EVENT_ID\n        \"\"\"\n\n        result = re.match(\n            r'^https?://maker\\.ifttt\\.com/use/'\n            r'(?P<webhook_id>[A-Z0-9_-]+)'\n            r'/?(?P<events>([A-Z0-9_-]+/?)+)?'\n            r'/?(?P<params>\\?.+)?$', url, re.I)\n\n        if result:\n            return NotifyIFTTT.parse_url(\n                '{schema}://{webhook_id}{events}{params}'.format(\n                    schema=NotifyIFTTT.secure_protocol,\n                    webhook_id=result.group('webhook_id'),\n                    events='' if not result.group('events')\n                    else '@{}'.format(result.group('events')),\n                    params='' if not result.group('params')\n                    else result.group('params')))\n\n        return None\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getlength(self, text, *args, **kwargs):\n        \"\"\"\n        Returns length (in pixels) of given text.\n        This is the amount by which following text should be offset.\n\n        .. versionadded:: 9.2.0\n        \"\"\"\n        width, height = self.font.getsize(text)\n        return width\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "        def _get_insert_token(token):\n            \"\"\"Returns either a whitespace or the line breaks from token.\"\"\"\n            # See issue484 why line breaks should be preserved.\n            m = re.search(r'((\\r\\n|\\r|\\n)+) *$', token.value)\n            if m is not None:\n                return sql.Token(T.Whitespace.Newline, m.groups()[0])\n            else:\n                return sql.Token(T.Whitespace, ' ')\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _slices_from_text(self, text):\n        last_break = 0\n        for match in self._lang_vars.period_context_re().finditer(text):\n            context = match.group() + match.group(\"after_tok\")\n            if self.text_contains_sentbreak(context):\n                yield slice(last_break, match.end())\n                if match.group(\"next_tok\"):\n                    # next sentence starts after whitespace\n                    last_break = match.start(\"next_tok\")\n                else:\n                    # next sentence starts at following punctuation\n                    last_break = match.end()\n        # The last sentence should not contain trailing whitespace.\n        yield slice(last_break, len(text.rstrip()))\n"}, {"role": "assistant", "content": "True"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_headers_finished(self) -> None:\n        disposition, options = parse_options_header(\n            self._current_part.content_disposition\n        )\n        try:\n            self._current_part.field_name = _user_safe_decode(\n                options[b\"name\"], self._charset\n            )\n        except KeyError:\n            raise MultiPartException(\n                'The Content-Disposition header field \"name\" must be ' \"provided.\"\n            )\n        if b\"filename\" in options:\n            self._current_files += 1\n            if self._current_files > self.max_files:\n                raise MultiPartException(\n                    f\"Too many files. Maximum number of files is {self.max_files}.\"\n                )\n            filename = _user_safe_decode(options[b\"filename\"], self._charset)\n            tempfile = SpooledTemporaryFile(max_size=self.max_file_size)\n            self._current_part.file = UploadFile(\n                file=tempfile,  # type: ignore[arg-type]\n                size=0,\n                filename=filename,\n                headers=Headers(raw=self._current_part.item_headers),\n            )\n        else:\n            self._current_fields += 1\n            if self._current_fields > self.max_fields:\n                raise MultiPartException(\n                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"\n                )\n            self._current_part.file = None\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_part_begin(self) -> None:\n        self._current_part = MultipartPart()\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getbbox(\n        self,\n        text,\n        mode=\"\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        anchor=None,\n    ):\n        \"\"\"\n        Returns bounding box (in pixels) of given text relative to given anchor\n        when rendered in font with provided direction, features, and language.\n\n        Use :py:meth:`getlength()` to get the offset of following text with\n        1/64 pixel precision. The bounding box includes extra margins for\n        some fonts, e.g. italics or accents.\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :param stroke_width: The width of the text stroke.\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left.\n                        See :ref:`text-anchors` for valid values.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n        \"\"\"\n        _string_length_check(text)\n        size, offset = self.font.getsize(\n            text, mode, direction, features, language, anchor\n        )\n        left, top = offset[0] - stroke_width, offset[1] - stroke_width\n        width, height = size[0] + 2 * stroke_width, size[1] + 2 * stroke_width\n        return left, top, left + width, top + height\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def run(argv: List[str]) -> None:\n    args = parse_command_line(argv)\n    remarshal(\n        args.input,\n        args.output,\n        args.input_format,\n        args.output_format,\n        json_indent=args.json_indent,\n        max_nodes=args.max_nodes,\n        ordered=args.ordered,\n        stringify=args.stringify,\n        unwrap=args.unwrap,\n        wrap=args.wrap,\n        yaml_options=args.yaml_options,\n    )\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n{\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_PUBKEY_INVALID;\n        return 0;\n    }\n\n    if (dh->params.q != NULL && BN_ucmp(dh->params.p, dh->params.q) < 0) {\n        *ret |= DH_CHECK_INVALID_Q_VALUE | DH_CHECK_PUBKEY_INVALID;\n        return 1;\n    }\n\n    return ossl_ffc_validate_public_key(&dh->params, pub_key, ret);\n}\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def get_available_name(self, name):\n        \"\"\"\n        Returns a filename that's free on the target storage system, and\n        available for new content to be written to.\n        \"\"\"\n        dir_name, file_name = os.path.split(name)\n        file_root, file_ext = os.path.splitext(file_name)\n        # If the filename already exists, add an underscore and a random 7\n        # character alphanumeric string (before the file extension, if one\n        # exists) to the filename until the generated filename doesn't exist.\n        while self.exists(name):\n            # file_ext includes the dot.\n            name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, get_random_string(7), file_ext))\n\n        return name\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def render_POST(self, request):\n        send_cors(request)\n\n        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))\n        medium = args[\"medium\"]\n        address = args[\"address\"]\n        roomId = args[\"room_id\"]\n        sender = args[\"sender\"]\n\n        verified_sender = None\n        if self.require_auth:\n            account = authV2(self.sydent, request)\n            verified_sender = sender\n            if account.userId != sender:\n                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")\n\n        globalAssocStore = GlobalAssociationStore(self.sydent)\n        mxid = globalAssocStore.getMxid(medium, address)\n        if mxid:\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_THREEPID_IN_USE\",\n                \"error\": \"Binding already known\",\n                \"mxid\": mxid,\n            }\n\n        if medium != \"email\":\n            request.setResponseCode(400)\n            return {\n                \"errcode\": \"M_UNRECOGNIZED\",\n                \"error\": \"Didn't understand medium '%s'\" % (medium,),\n            }\n\n        if not (0 < len(address) <= MAX_EMAIL_ADDRESS_LENGTH):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'Invalid email provided'\n            }\n\n        token = self._randomString(128)\n\n        tokenStore = JoinTokenStore(self.sydent)\n\n        ephemeralPrivateKey = nacl.signing.SigningKey.generate()\n        ephemeralPublicKey = ephemeralPrivateKey.verify_key\n\n        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)\n        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)\n\n        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)\n        tokenStore.storeToken(medium, address, roomId, sender, token)\n\n        # Variables to substitute in the template.\n        substitutions = {}\n        # Include all arguments sent via the request.\n        for k, v in args.items():\n            if isinstance(v, string_types):\n                substitutions[k] = v\n        substitutions[\"token\"] = token\n\n        # Substitutions that the template requires, but are optional to provide\n        # to the API.\n        extra_substitutions = [\n            'sender_display_name',\n            'token',\n            'room_name',\n            'bracketed_room_name',\n            'room_avatar_url',\n            'sender_avatar_url',\n            'guest_user_id',\n            'guest_access_token',\n        ]\n        for k in extra_substitutions:\n            substitutions.setdefault(k, '')\n\n        substitutions[\"bracketed_verified_sender\"] = \"\"\n        if verified_sender:\n            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)\n\n        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64\n        if substitutions[\"room_name\"] != '':\n            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]\n\n        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location\n        if 'org.matrix.web_client_location' in substitutions:\n            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")\n\n        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')\n        substitutions[\"subject_header_value\"] = subject_header.encode()\n\n        brand = self.sydent.brand_from_request(request)\n        templateFile = self.sydent.get_branded_template(\n            brand,\n            \"invite_template.eml\",\n            ('email', 'email.invite_template'),\n        )\n\n        sendEmail(self.sydent, templateFile, address, substitutions)\n\n        pubKey = self.sydent.keyring.ed25519.verify_key\n        pubKeyBase64 = encode_base64(pubKey.encode())\n\n        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)\n\n        keysToReturn = []\n        keysToReturn.append({\n            \"public_key\": pubKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",\n        })\n        keysToReturn.append({\n            \"public_key\": ephemeralPublicKeyBase64,\n            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",\n        })\n\n        resp = {\n            \"token\": token,\n            \"public_key\": pubKeyBase64,\n            \"public_keys\": keysToReturn,\n            \"display_name\": self.redact_email_address(address),\n        }\n\n        return resp\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n#ifndef FIPS_MODULE\n    unsigned l;\n#endif\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    if (dh->params.q != NULL\n        && BN_num_bits(dh->params.q) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_Q_TOO_LARGE);\n        return 0;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_secure_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else {\n        priv_key = dh->priv_key;\n    }\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else {\n        pub_key = dh->pub_key;\n    }\n    if (generate_new_key) {\n        /* Is it an approved safe prime ?*/\n        if (DH_get_nid(dh) != NID_undef) {\n            int max_strength =\n                    ossl_ifc_ffc_compute_security_bits(BN_num_bits(dh->params.p));\n\n            if (dh->params.q == NULL\n                || dh->length > BN_num_bits(dh->params.q))\n                goto err;\n            /* dh->length = maximum bit length of generated private key */\n            if (!ossl_ffc_generate_private_key(ctx, &dh->params, dh->length,\n                                               max_strength, priv_key))\n                goto err;\n        } else {\n#ifdef FIPS_MODULE\n            if (dh->params.q == NULL)\n                goto err;\n#else\n            if (dh->params.q == NULL) {\n                /* secret exponent length, must satisfy 2^(l-1) <= p */\n                if (dh->length != 0\n                    && dh->length >= BN_num_bits(dh->params.p))\n                    goto err;\n                l = dh->length ? dh->length : BN_num_bits(dh->params.p) - 1;\n                if (!BN_priv_rand_ex(priv_key, l, BN_RAND_TOP_ONE,\n                                     BN_RAND_BOTTOM_ANY, 0, ctx))\n                    goto err;\n                /*\n                 * We handle just one known case where g is a quadratic non-residue:\n                 * for g = 2: p % 8 == 3\n                 */\n                if (BN_is_word(dh->params.g, DH_GENERATOR_2)\n                    && !BN_is_bit_set(dh->params.p, 2)) {\n                    /* clear bit 0, since it won't be a secret anyway */\n                    if (!BN_clear_bit(priv_key, 0))\n                        goto err;\n                }\n            } else\n#endif\n            {\n                /* Do a partial check for invalid p, q, g */\n                if (!ossl_ffc_params_simple_validate(dh->libctx, &dh->params,\n                                                     FFC_PARAM_TYPE_DH, NULL))\n                    goto err;\n                /*\n                 * For FFC FIPS 186-4 keygen\n                 * security strength s = 112,\n                 * Max Private key size N = len(q)\n                 */\n                if (!ossl_ffc_generate_private_key(ctx, &dh->params,\n                                                   BN_num_bits(dh->params.q),\n                                                   MIN_STRENGTH,\n                                                   priv_key))\n                    goto err;\n            }\n        }\n    }\n\n    if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))\n        goto err;\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    dh->dirty_cnt++;\n    ok = 1;\n err:\n    if (ok != 1)\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n\n    if (pub_key != dh->pub_key)\n        BN_free(pub_key);\n    if (priv_key != dh->priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getlength(self, text, mode=\"\", direction=None, features=None, language=None):\n        \"\"\"\n        Returns length (in pixels with 1/64 precision) of given text when rendered\n        in font with provided direction, features, and language.\n\n        This is the amount by which following text should be offset.\n        Text bounding box may extend past the length in some fonts,\n        e.g. when using italics or accents.\n\n        The result is returned as a float; it is a whole number if using basic layout.\n\n        Note that the sum of two lengths may not equal the length of a concatenated\n        string due to kerning. If you need to adjust for kerning, include the following\n        character and subtract its length.\n\n        For example, instead of ::\n\n          hello = font.getlength(\"Hello\")\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # not adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # may fail\n\n        use ::\n\n          hello = font.getlength(\"HelloW\") - font.getlength(\"W\")  # adjusted for kerning\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # True\n\n        or disable kerning with (requires libraqm) ::\n\n          hello = draw.textlength(\"Hello\", font, features=[\"-kern\"])\n          world = draw.textlength(\"World\", font, features=[\"-kern\"])\n          hello_world = hello + world  # kerning is disabled, no need to adjust\n          assert hello_world == draw.textlength(\"HelloWorld\", font, features=[\"-kern\"])\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to measure.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :return: Width for horizontal, height for vertical text.\n        \"\"\"\n        _string_length_check(text)\n        return self.font.getlength(text, mode, direction, features, language) / 64\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def encode(self, types: Iterable[TypeStr], args: Iterable[Any]) -> bytes:\n        \"\"\"\n        Encodes the python values in ``args`` as a sequence of binary values of\n        the ABI types in ``types`` via the head-tail mechanism.\n\n        :param types: A list or tuple of string representations of the ABI types\n            that will be used for encoding e.g.  ``('uint256', 'bytes[]',\n            '(int,int)')``\n        :param args: A list or tuple of python values to be encoded.\n\n        :returns: The head-tail encoded binary representation of the python\n            values in ``args`` as values of the ABI types in ``types``.\n        \"\"\"\n        # validate encode types\n        validate_codec_types(types)\n\n        # validate encode args\n        validate_list_like_param(args, \"args\")\n\n        encoders = [self._registry.get_encoder(type_str) for type_str in types]\n\n        encoder = TupleEncoder(encoders=encoders)\n\n        return encoder(args)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def serve(self):\n        \"\"\"\n        Serve client connections.\n\n        Begin listening for client connections, spinning off new KmipSessions\n        as connections are handled. Set up signal handling to shutdown\n        connection service as needed.\n        \"\"\"\n        self._socket.listen(5)\n\n        def _signal_handler(signal_number, stack_frame):\n            self._is_serving = False\n\n            # Python3.5+ silently ignores SIGINT and retries system calls if\n            # the signal handler does not raise an exception. Explicitly\n            # detect SIGINT and raise a KeyboardInterrupt exception to regain\n            # old functionality.\n            if signal_number == signal.SIGINT:\n                raise KeyboardInterrupt(\"SIGINT received\")\n\n        signal.signal(signal.SIGINT, _signal_handler)\n        signal.signal(signal.SIGTERM, _signal_handler)\n\n        self._logger.info(\"Starting connection service...\")\n\n        while self._is_serving:\n            try:\n                connection, address = self._socket.accept()\n            except socket.timeout:\n                # Setting the default socket timeout to break hung connections\n                # will cause accept to periodically raise socket.timeout. This\n                # is expected behavior, so ignore it and retry accept.\n                pass\n            except socket.error as e:\n                self._logger.warning(\n                    \"Error detected while establishing new connection.\"\n                )\n                self._logger.exception(e)\n            except KeyboardInterrupt:\n                self._logger.warning(\"Interrupting connection service.\")\n                self._is_serving = False\n                break\n            except Exception as e:\n                self._logger.warning(\n                    \"Error detected while establishing new connection.\"\n                )\n                self._logger.exception(e)\n            else:\n                self._setup_connection_handler(connection, address)\n\n        self._logger.info(\"Stopping connection service.\")\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getmask(self, text, mode=\"\", *args, **kwargs):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :return: An internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module.\n        \"\"\"\n        _string_length_check(text)\n        return self.font.getmask(text, mode)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def __init__(self, handler, max_frame_length=DEFAULT_MAX_FRAME_LENGTH):\n        self.handler = handler\n        self.protocol_version = None\n        self.support_legacy_versions = True\n        self.supported_protocols = []\n        self.origin_checker = None\n        self.max_frame_length = max_frame_length\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def debug_decisions(self, text):\n        \"\"\"\n        Classifies candidate periods as sentence breaks, yielding a dict for\n        each that may be used to understand why the decision was made.\n\n        See format_debug_decision() to help make this output readable.\n        \"\"\"\n\n        for match, decision_text in self._match_potential_end_contexts(text):\n            tokens = self._tokenize_words(decision_text)\n            tokens = list(self._annotate_first_pass(tokens))\n            while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars):\n                tokens.pop(0)\n            yield {\n                \"period_index\": match.end() - 1,\n                \"text\": decision_text,\n                \"type1\": tokens[0].type,\n                \"type2\": tokens[1].type,\n                \"type1_in_abbrs\": bool(tokens[0].abbr),\n                \"type1_is_initial\": bool(tokens[0].is_initial),\n                \"type2_is_sent_starter\": tokens[1].type_no_sentperiod\n                in self._params.sent_starters,\n                \"type2_ortho_heuristic\": self._ortho_heuristic(tokens[1]),\n                \"type2_ortho_contexts\": set(\n                    self._params._debug_ortho_context(tokens[1].type_no_sentperiod)\n                ),\n                \"collocation\": (\n                    tokens[0].type_no_sentperiod,\n                    tokens[1].type_no_sentperiod,\n                )\n                in self._params.collocations,\n                \"reason\": self._second_pass_annotation(tokens[0], tokens[1])\n                or REASON_DEFAULT_DECISION,\n                \"break_decision\": tokens[0].sentbreak,\n            }\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _load_post_and_files(self):\n        \"\"\"Populate self._post and self._files if the content-type is a form type\"\"\"\n        if self.method != \"POST\":\n            self._post, self._files = (\n                QueryDict(encoding=self._encoding),\n                MultiValueDict(),\n            )\n            return\n        if self._read_started and not hasattr(self, \"_body\"):\n            self._mark_post_parse_error()\n            return\n\n        if self.content_type == \"multipart/form-data\":\n            if hasattr(self, \"_body\"):\n                # Use already read data\n                data = BytesIO(self._body)\n            else:\n                data = self\n            try:\n                self._post, self._files = self.parse_file_upload(self.META, data)\n            except (MultiPartParserError, TooManyFilesSent):\n                # An error occurred while parsing POST data. Since when\n                # formatting the error the request handler might access\n                # self.POST, set self._post and self._file to prevent\n                # attempts to parse POST data again.\n                self._mark_post_parse_error()\n                raise\n        elif self.content_type == \"application/x-www-form-urlencoded\":\n            self._post, self._files = (\n                QueryDict(self.body, encoding=self._encoding),\n                MultiValueDict(),\n            )\n        else:\n            self._post, self._files = (\n                QueryDict(encoding=self._encoding),\n                MultiValueDict(),\n            )\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_default_span_name(environ):\n    \"\"\"\n    Default span name is the HTTP method and URL path, or just the method.\n    https://github.com/open-telemetry/opentelemetry-specification/pull/3165\n    https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/#name\n\n    Args:\n        environ: The WSGI environ object.\n    Returns:\n        The span name.\n    \"\"\"\n    method = sanitize_method(environ.get(\"REQUEST_METHOD\", \"\").strip())\n    path = environ.get(\"PATH_INFO\", \"\").strip()\n    if method and path:\n        return f\"{method} {path}\"\n    return method\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def get_contents_from_bundle(bundle: ZipFile) -> dict[str, str]:\n    check_is_safe_zip(bundle)\n    return {\n        remove_root(file_name): bundle.read(file_name).decode()\n        for file_name in bundle.namelist()\n        if is_valid_config(file_name)\n    }\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *z = NULL, *pminus1;\n    int ret = -1;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        goto err;\n    }\n\n    if (dh->params.q != NULL\n        && BN_num_bits(dh->params.q) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_Q_TOO_LARGE);\n        goto err;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    pminus1 = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    if (z == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        ERR_raise(ERR_LIB_DH, DH_R_NO_PRIVATE_VALUE);\n        goto err;\n    }\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      dh->lock, dh->params.p, ctx);\n        BN_set_flags(dh->priv_key, BN_FLG_CONSTTIME);\n        if (!mont)\n            goto err;\n    }\n\n    /* (Step 1) Z = pub_key^priv_key mod p */\n    if (!dh->meth->bn_mod_exp(dh, z, pub_key, dh->priv_key, dh->params.p, ctx,\n                              mont)) {\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* (Step 2) Error if z <= 1 or z = p - 1 */\n    if (BN_copy(pminus1, dh->params.p) == NULL\n        || !BN_sub_word(pminus1, 1)\n        || BN_cmp(z, BN_value_one()) <= 0\n        || BN_cmp(z, pminus1) == 0) {\n        ERR_raise(ERR_LIB_DH, DH_R_INVALID_SECRET);\n        goto err;\n    }\n\n    /* return the padded key, i.e. same number of bytes as the modulus */\n    ret = BN_bn2binpad(z, key, BN_num_bytes(dh->params.p));\n err:\n    BN_clear(z); /* (Step 2) destroy intermediate values */\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _construct_forms(self):\n        # instantiate all the forms and put them in self.forms\n        self.forms = []\n        for i in xrange(min(self.total_form_count(), self.absolute_max)):\n            self.forms.append(self._construct_form(i))\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_header_end(self) -> None:\n        field = self._current_partial_header_name.lower()\n        if field == b\"content-disposition\":\n            self._current_part.content_disposition = self._current_partial_header_value\n        self._current_part.item_headers.append(\n            (field, self._current_partial_header_value)\n        )\n        self._current_partial_header_name = b\"\"\n        self._current_partial_header_value = b\"\"\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def handle_message(self, stream, payload):\n        try:\n            payload = self.decode_payload(payload)\n        except salt.exceptions.SaltDeserializationError:\n            self.stream.send(self.encode_payload({\"msg\": \"bad load\"}))\n            return\n        # XXX: Is header really needed?\n        reply = yield self.message_handler(payload)\n        self.stream.send(self.encode_payload(reply))\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "        def getvalue(self):\n            data = b\"\".join(self.data)\n            if not self.opcode & 8 and self.decompressor:\n                data = self.decompressor.decompress(data + b\"\\x00\\x00\\xff\\xff\", self.max_frame_length)\n                if self.decompressor.unconsumed_tail:\n                    raise FailedConnectionError(\n                        1009,\n                        \"Incoming compressed frame exceeds length limit of {} bytes.\".format(self.max_frame_length))\n\n            if self.decoder:\n                data = self.decoder.decode(data, self.finished)\n            return data\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    async def parse(self) -> FormData:\n        # Parse the Content-Type header to get the multipart boundary.\n        _, params = parse_options_header(self.headers[\"Content-Type\"])\n        charset = params.get(b\"charset\", \"utf-8\")\n        if type(charset) == bytes:\n            charset = charset.decode(\"latin-1\")\n        self._charset = charset\n        try:\n            boundary = params[b\"boundary\"]\n        except KeyError:\n            raise MultiPartException(\"Missing boundary in multipart.\")\n\n        # Callbacks dictionary.\n        callbacks = {\n            \"on_part_begin\": self.on_part_begin,\n            \"on_part_data\": self.on_part_data,\n            \"on_part_end\": self.on_part_end,\n            \"on_header_field\": self.on_header_field,\n            \"on_header_value\": self.on_header_value,\n            \"on_header_end\": self.on_header_end,\n            \"on_headers_finished\": self.on_headers_finished,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.MultipartParser(boundary, callbacks)\n        # Feed the parser with data from the request.\n        async for chunk in self.stream:\n            parser.write(chunk)\n            # Write file data, it needs to use await with the UploadFile methods that\n            # call the corresponding file methods *in a threadpool*, otherwise, if\n            # they were called directly in the callback methods above (regular,\n            # non-async functions), that would block the event loop in the main thread.\n            for part, data in self._file_parts_to_write:\n                assert part.file  # for type checkers\n                await part.file.write(data)\n            for part in self._file_parts_to_finish:\n                assert part.file  # for type checkers\n                await part.file.seek(0)\n            self._file_parts_to_write.clear()\n            self._file_parts_to_finish.clear()\n\n        parser.finalize()\n        return FormData(self.items)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def response_for_exception(request, exc):\n    if isinstance(exc, Http404):\n        if settings.DEBUG:\n            response = debug.technical_404_response(request, exc)\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 404, exc\n            )\n\n    elif isinstance(exc, PermissionDenied):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 403, exc\n        )\n        log_response(\n            \"Forbidden (Permission denied): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    elif isinstance(exc, MultiPartParserError):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 400, exc\n        )\n        log_response(\n            \"Bad request (Unable to parse request body): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    elif isinstance(exc, BadRequest):\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n        log_response(\n            \"%s: %s\",\n            str(exc),\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n    elif isinstance(exc, SuspiciousOperation):\n        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent, TooManyFilesSent)):\n            # POST data can't be accessed again, otherwise the original\n            # exception would be raised.\n            request._mark_post_parse_error()\n\n        # The request logger receives events for any problematic request\n        # The security logger receives events for all SuspiciousOperations\n        security_logger = logging.getLogger(\n            \"django.security.%s\" % exc.__class__.__name__\n        )\n        security_logger.error(\n            str(exc),\n            exc_info=exc,\n            extra={\"status_code\": 400, \"request\": request},\n        )\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n\n    else:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(\n            request, get_resolver(get_urlconf()), sys.exc_info()\n        )\n        log_response(\n            \"%s: %s\",\n            response.reason_phrase,\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    # Force a TemplateResponse to be rendered.\n    if not getattr(response, \"is_rendered\", True) and callable(\n        getattr(response, \"render\", None)\n    ):\n        response = response.render()\n\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _handle_hybi_request(self, environ):\n        if 'eventlet.input' in environ:\n            sock = environ['eventlet.input'].get_socket()\n        elif 'gunicorn.socket' in environ:\n            sock = environ['gunicorn.socket']\n        else:\n            raise Exception('No eventlet.input or gunicorn.socket present in environ.')\n\n        hybi_version = environ['HTTP_SEC_WEBSOCKET_VERSION']\n        if hybi_version not in ('8', '13', ):\n            raise BadRequest(status='426 Upgrade Required',\n                             headers=[('Sec-WebSocket-Version', '8, 13')])\n        self.protocol_version = int(hybi_version)\n        if 'HTTP_SEC_WEBSOCKET_KEY' not in environ:\n            # That's bad.\n            raise BadRequest()\n        origin = environ.get(\n            'HTTP_ORIGIN',\n            (environ.get('HTTP_SEC_WEBSOCKET_ORIGIN', '')\n             if self.protocol_version <= 8 else ''))\n        if self.origin_checker is not None:\n            if not self.origin_checker(environ.get('HTTP_HOST'), origin):\n                raise BadRequest(status='403 Forbidden')\n        protocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL', None)\n        negotiated_protocol = None\n        if protocols:\n            for p in (i.strip() for i in protocols.split(',')):\n                if p in self.supported_protocols:\n                    negotiated_protocol = p\n                    break\n\n        key = environ['HTTP_SEC_WEBSOCKET_KEY']\n        response = base64.b64encode(sha1(six.b(key) + PROTOCOL_GUID).digest())\n        handshake_reply = [b\"HTTP/1.1 101 Switching Protocols\",\n                           b\"Upgrade: websocket\",\n                           b\"Connection: Upgrade\",\n                           b\"Sec-WebSocket-Accept: \" + response]\n        if negotiated_protocol:\n            handshake_reply.append(b\"Sec-WebSocket-Protocol: \" + six.b(negotiated_protocol))\n\n        parsed_extensions = {}\n        extensions = self._parse_extension_header(environ.get(\"HTTP_SEC_WEBSOCKET_EXTENSIONS\"))\n\n        deflate = self._negotiate_permessage_deflate(extensions)\n        if deflate is not None:\n            parsed_extensions[\"permessage-deflate\"] = deflate\n\n        formatted_ext = self._format_extension_header(parsed_extensions)\n        if formatted_ext is not None:\n            handshake_reply.append(b\"Sec-WebSocket-Extensions: \" + formatted_ext)\n\n        sock.sendall(b'\\r\\n'.join(handshake_reply) + b'\\r\\n\\r\\n')\n        return RFC6455WebSocket(sock, environ, self.protocol_version,\n                                protocol=negotiated_protocol,\n                                extensions=parsed_extensions,\n                                max_frame_length=self.max_frame_length)\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def handle_message(self, stream, payload):\n        try:\n            payload = self.decode_payload(payload)\n        except salt.exceptions.SaltDeserializationError:\n            self.stream.send(self.encode_payload({\"msg\": \"bad load\"}))\n            return\n        # XXX: Is header really needed?\n        reply = yield self.message_handler(payload)\n        self.stream.send(self.encode_payload(reply))\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def is_valid_client_secret(client_secret):\n    \"\"\"Validate that a given string matches the client_secret regex defined by the spec\n\n    :param client_secret: The client_secret to validate\n    :type client_secret: str\n\n    :return: Whether the client_secret is valid\n    :rtype: bool\n    \"\"\"\n    return (\n        0 < len(client_secret) <= 255\n        and CLIENT_SECRET_REGEX.match(client_secret) is not None\n    )\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def collect_request_attributes(environ):\n    \"\"\"Collects HTTP request attributes from the PEP3333-conforming\n    WSGI environ and returns a dictionary to be used as span creation attributes.\n    \"\"\"\n\n    result = {\n        SpanAttributes.HTTP_METHOD: sanitize_method(environ.get(\"REQUEST_METHOD\")),\n        SpanAttributes.HTTP_SERVER_NAME: environ.get(\"SERVER_NAME\"),\n        SpanAttributes.HTTP_SCHEME: environ.get(\"wsgi.url_scheme\"),\n    }\n\n    host_port = environ.get(\"SERVER_PORT\")\n    if host_port is not None and not host_port == \"\":\n        result.update({SpanAttributes.NET_HOST_PORT: int(host_port)})\n\n    setifnotnone(result, SpanAttributes.HTTP_HOST, environ.get(\"HTTP_HOST\"))\n    target = environ.get(\"RAW_URI\")\n    if target is None:  # Note: `\"\" or None is None`\n        target = environ.get(\"REQUEST_URI\")\n    if target is not None:\n        result[SpanAttributes.HTTP_TARGET] = target\n    else:\n        result[SpanAttributes.HTTP_URL] = remove_url_credentials(\n            wsgiref_util.request_uri(environ)\n        )\n\n    remote_addr = environ.get(\"REMOTE_ADDR\")\n    if remote_addr:\n        result[SpanAttributes.NET_PEER_IP] = remote_addr\n    remote_host = environ.get(\"REMOTE_HOST\")\n    if remote_host and remote_host != remote_addr:\n        result[SpanAttributes.NET_PEER_NAME] = remote_host\n\n    user_agent = environ.get(\"HTTP_USER_AGENT\")\n    if user_agent is not None and len(user_agent) > 0:\n        result[SpanAttributes.HTTP_USER_AGENT] = user_agent\n\n    setifnotnone(\n        result, SpanAttributes.NET_PEER_PORT, environ.get(\"REMOTE_PORT\")\n    )\n    flavor = environ.get(\"SERVER_PROTOCOL\", \"\")\n    if flavor.upper().startswith(_HTTP_VERSION_PREFIX):\n        flavor = flavor[len(_HTTP_VERSION_PREFIX) :]\n    if flavor:\n        result[SpanAttributes.HTTP_FLAVOR] = flavor\n\n    return result\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n#ifndef FIPS_MODULE\n    unsigned l;\n#endif\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    if (dh->params.q != NULL\n        && BN_num_bits(dh->params.q) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_Q_TOO_LARGE);\n        return 0;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_secure_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else {\n        priv_key = dh->priv_key;\n    }\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else {\n        pub_key = dh->pub_key;\n    }\n    if (generate_new_key) {\n        /* Is it an approved safe prime ?*/\n        if (DH_get_nid(dh) != NID_undef) {\n            int max_strength =\n                    ossl_ifc_ffc_compute_security_bits(BN_num_bits(dh->params.p));\n\n            if (dh->params.q == NULL\n                || dh->length > BN_num_bits(dh->params.q))\n                goto err;\n            /* dh->length = maximum bit length of generated private key */\n            if (!ossl_ffc_generate_private_key(ctx, &dh->params, dh->length,\n                                               max_strength, priv_key))\n                goto err;\n        } else {\n#ifdef FIPS_MODULE\n            if (dh->params.q == NULL)\n                goto err;\n#else\n            if (dh->params.q == NULL) {\n                /* secret exponent length, must satisfy 2^(l-1) <= p */\n                if (dh->length != 0\n                    && dh->length >= BN_num_bits(dh->params.p))\n                    goto err;\n                l = dh->length ? dh->length : BN_num_bits(dh->params.p) - 1;\n                if (!BN_priv_rand_ex(priv_key, l, BN_RAND_TOP_ONE,\n                                     BN_RAND_BOTTOM_ANY, 0, ctx))\n                    goto err;\n                /*\n                 * We handle just one known case where g is a quadratic non-residue:\n                 * for g = 2: p % 8 == 3\n                 */\n                if (BN_is_word(dh->params.g, DH_GENERATOR_2)\n                    && !BN_is_bit_set(dh->params.p, 2)) {\n                    /* clear bit 0, since it won't be a secret anyway */\n                    if (!BN_clear_bit(priv_key, 0))\n                        goto err;\n                }\n            } else\n#endif\n            {\n                /* Do a partial check for invalid p, q, g */\n                if (!ossl_ffc_params_simple_validate(dh->libctx, &dh->params,\n                                                     FFC_PARAM_TYPE_DH, NULL))\n                    goto err;\n                /*\n                 * For FFC FIPS 186-4 keygen\n                 * security strength s = 112,\n                 * Max Private key size N = len(q)\n                 */\n                if (!ossl_ffc_generate_private_key(ctx, &dh->params,\n                                                   BN_num_bits(dh->params.q),\n                                                   MIN_STRENGTH,\n                                                   priv_key))\n                    goto err;\n            }\n        }\n    }\n\n    if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))\n        goto err;\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    dh->dirty_cnt++;\n    ok = 1;\n err:\n    if (ok != 1)\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n\n    if (pub_key != dh->pub_key)\n        BN_free(pub_key);\n    if (priv_key != dh->priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def send(self, anyway=False, prefetch=False):\n        \"\"\"Sends the request. Returns True of successful, False if not.\n        If there was an HTTPError during transmission,\n        self.response.status_code will contain the HTTPError code.\n\n        Once a request is successfully sent, `sent` will equal True.\n\n        :param anyway: If True, request will be sent, even if it has\n        already been sent.\n        \"\"\"\n\n        # Build the URL\n        url = self.full_url\n\n        # Logging\n        if self.config.get('verbose'):\n            self.config.get('verbose').write('%s   %s   %s\\n' % (\n                datetime.now().isoformat(), self.method, url\n            ))\n\n        # Nottin' on you.\n        body = None\n        content_type = None\n\n        # Multi-part file uploads.\n        if self.files:\n            (body, content_type) = self._enc_files\n        else:\n            if self.data:\n\n                body = self._enc_data\n                if isinstance(self.data, str):\n                    content_type = None\n                else:\n                    content_type = 'application/x-www-form-urlencoded'\n\n        # Add content-type if it wasn't explicitly provided.\n        if (content_type) and (not 'content-type' in self.headers):\n            self.headers['Content-Type'] = content_type\n\n        # Use .netrc auth if none was provided.\n        if not self.auth and self.config.get('trust_env'):\n            self.auth = get_netrc_auth(url)\n\n        if self.auth:\n            if isinstance(self.auth, tuple) and len(self.auth) == 2:\n                # special-case basic HTTP auth\n                self.auth = HTTPBasicAuth(*self.auth)\n\n            # Allow auth to make its changes.\n            r = self.auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n        _p = urlparse(url)\n        proxy = self.proxies.get(_p.scheme)\n\n        if proxy:\n            conn = poolmanager.proxy_from_url(proxy)\n            _proxy = urlparse(proxy)\n            if '@' in _proxy.netloc:\n                auth, url = _proxy.netloc.split('@', 1)\n                self.proxy_auth = HTTPProxyAuth(*auth.split(':', 1))\n                r = self.proxy_auth(self)\n                self.__dict__.update(r.__dict__)\n        else:\n            # Check to see if keep_alive is allowed.\n            if self.config.get('keep_alive'):\n                conn = self._poolmanager.connection_from_url(url)\n            else:\n                conn = connectionpool.connection_from_url(url)\n\n        if url.startswith('https') and self.verify:\n\n            cert_loc = None\n\n            # Allow self-specified cert location.\n            if self.verify is not True:\n                cert_loc = self.verify\n\n            # Look for configuration.\n            if not cert_loc and self.config.get('trust_env'):\n                cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n\n            # Curl compatiblity.\n            if not cert_loc and self.config.get('trust_env'):\n                cert_loc = os.environ.get('CURL_CA_BUNDLE')\n\n            # Use the awesome certifi list.\n            if not cert_loc:\n                cert_loc = __import__('certifi').where()\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n            conn.ca_certs = cert_loc\n        else:\n            conn.cert_reqs = 'CERT_NONE'\n            conn.ca_certs = None\n\n        if self.cert and self.verify:\n            if len(self.cert) == 2:\n                conn.cert_file = self.cert[0]\n                conn.key_file = self.cert[1]\n            else:\n                conn.cert_file = self.cert\n\n        if not self.sent or anyway:\n\n            if self.cookies:\n\n                # Skip if 'cookie' header is explicitly set.\n                if 'cookie' not in self.headers:\n\n                    # Simple cookie with our dict.\n                    c = SimpleCookie()\n                    for (k, v) in list(self.cookies.items()):\n                        c[k] = v\n\n                    # Turn it into a header.\n                    cookie_header = c.output(header='', sep='; ').strip()\n\n                    # Attach Cookie header to request.\n                    self.headers['Cookie'] = cookie_header\n\n            # Pre-request hook.\n            r = dispatch_hook('pre_request', self.hooks, self)\n            self.__dict__.update(r.__dict__)\n\n            try:\n                # The inner try .. except re-raises certain exceptions as\n                # internal exception types; the outer suppresses exceptions\n                # when safe mode is set.\n                try:\n                    # Send the request.\n                    r = conn.urlopen(\n                        method=self.method,\n                        url=self.path_url,\n                        body=body,\n                        headers=self.headers,\n                        redirect=False,\n                        assert_same_host=False,\n                        preload_content=False,\n                        decode_content=False,\n                        retries=self.config.get('max_retries', 0),\n                        timeout=self.timeout,\n                    )\n                    self.sent = True\n\n                except MaxRetryError as e:\n                    raise ConnectionError(e)\n\n                except (_SSLError, _HTTPError) as e:\n                    if self.verify and isinstance(e, _SSLError):\n                        raise SSLError(e)\n\n                    raise Timeout('Request timed out.')\n\n            except RequestException as e:\n                if self.config.get('safe_mode', False):\n                    # In safe mode, catch the exception and attach it to\n                    # a blank urllib3.HTTPResponse object.\n                    r = HTTPResponse()\n                    r.error = e\n                else:\n                    raise\n\n            self._build_response(r)\n\n            # Response manipulation hook.\n            self.response = dispatch_hook('response', self.hooks, self.response)\n\n            # Post-request hook.\n            r = dispatch_hook('post_request', self.hooks, self)\n            self.__dict__.update(r.__dict__)\n\n            # If prefetch is True, mark content as consumed.\n            if prefetch:\n                # Save the response.\n                self.response.content\n\n            if self.config.get('danger_mode'):\n                self.response.raise_for_status()\n\n            return self.sent\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _load_post_and_files(self):\n        \"\"\"Populate self._post and self._files if the content-type is a form type\"\"\"\n        if self.method != 'POST':\n            self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()\n            return\n        if self._read_started and not hasattr(self, '_body'):\n            self._mark_post_parse_error()\n            return\n\n        if self.content_type == 'multipart/form-data':\n            if hasattr(self, '_body'):\n                # Use already read data\n                data = BytesIO(self._body)\n            else:\n                data = self\n            try:\n                self._post, self._files = self.parse_file_upload(self.META, data)\n            except (MultiPartParserError, TooManyFilesSent):\n                # An error occurred while parsing POST data. Since when\n                # formatting the error the request handler might access\n                # self.POST, set self._post and self._file to prevent\n                # attempts to parse POST data again.\n                self._mark_post_parse_error()\n                raise\n        elif self.content_type == 'application/x-www-form-urlencoded':\n            self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()\n        else:\n            self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def on_part_data(self, data: bytes, start: int, end: int) -> None:\n        message_bytes = data[start:end]\n        if self._current_part.file is None:\n            self._current_part.data += message_bytes\n        else:\n            self._file_parts_to_write.append((self._current_part, message_bytes))\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *z = NULL, *pminus1;\n    int ret = -1;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        goto err;\n    }\n\n    if (dh->params.q != NULL\n        && BN_num_bits(dh->params.q) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_Q_TOO_LARGE);\n        goto err;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    pminus1 = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    if (z == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        ERR_raise(ERR_LIB_DH, DH_R_NO_PRIVATE_VALUE);\n        goto err;\n    }\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      dh->lock, dh->params.p, ctx);\n        BN_set_flags(dh->priv_key, BN_FLG_CONSTTIME);\n        if (!mont)\n            goto err;\n    }\n\n    /* (Step 1) Z = pub_key^priv_key mod p */\n    if (!dh->meth->bn_mod_exp(dh, z, pub_key, dh->priv_key, dh->params.p, ctx,\n                              mont)) {\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* (Step 2) Error if z <= 1 or z = p - 1 */\n    if (BN_copy(pminus1, dh->params.p) == NULL\n        || !BN_sub_word(pminus1, 1)\n        || BN_cmp(z, BN_value_one()) <= 0\n        || BN_cmp(z, pminus1) == 0) {\n        ERR_raise(ERR_LIB_DH, DH_R_INVALID_SECRET);\n        goto err;\n    }\n\n    /* return the padded key, i.e. same number of bytes as the modulus */\n    ret = BN_bn2binpad(z, key, BN_num_bytes(dh->params.p));\n err:\n    BN_clear(z); /* (Step 2) destroy intermediate values */\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def parse(self):\n        # Call the actual parse routine and close all open files in case of\n        # errors. This is needed because if exceptions are thrown the\n        # MultiPartParser will not be garbage collected immediately and\n        # resources would be kept alive. This is only needed for errors because\n        # the Request object closes all uploaded files at the end of the\n        # request.\n        try:\n            return self._parse()\n        except Exception:\n            if hasattr(self, \"_files\"):\n                for _, files in self._files.lists():\n                    for fileobj in files:\n                        fileobj.close()\n            raise\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve(request, path, document_root=None, show_indexes=False):\n    \"\"\"\n    Serve static files below a given point in the directory structure.\n\n    To use, put a URL pattern such as::\n\n        (r'^(?P<path>.*)$', 'django.views.static.serve', {'document_root' : '/path/to/my/files/'})\n\n    in your URLconf. You must provide the ``document_root`` param. You may\n    also set ``show_indexes`` to ``True`` if you'd like to serve a basic index\n    of the directory.  This index view will use the template hardcoded below,\n    but if you'd like to override it, you can create a template called\n    ``static/directory_index.html``.\n    \"\"\"\n    path = posixpath.normpath(urllib.unquote(path))\n    path = path.lstrip('/')\n    newpath = ''\n    for part in path.split('/'):\n        if not part:\n            # Strip empty path components.\n            continue\n        drive, part = os.path.splitdrive(part)\n        head, part = os.path.split(part)\n        if part in (os.curdir, os.pardir):\n            # Strip '.' and '..' in path.\n            continue\n        newpath = os.path.join(newpath, part).replace('\\\\', '/')\n    if newpath and path != newpath:\n        return HttpResponseRedirect(newpath)\n    fullpath = os.path.join(document_root, newpath)\n    if os.path.isdir(fullpath):\n        if show_indexes:\n            return directory_index(newpath, fullpath)\n        raise Http404(_(u\"Directory indexes are not allowed here.\"))\n    if not os.path.exists(fullpath):\n        raise Http404(_(u'\"%(path)s\" does not exist') % {'path': fullpath})\n    # Respect the If-Modified-Since header.\n    statobj = os.stat(fullpath)\n    mimetype, encoding = mimetypes.guess_type(fullpath)\n    mimetype = mimetype or 'application/octet-stream'\n    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                              statobj.st_mtime, statobj.st_size):\n        return HttpResponseNotModified(mimetype=mimetype)\n    f = open(fullpath, 'rb')\n    response = HttpResponse(iter(lambda: f.read(STREAM_CHUNK_SIZE), ''), mimetype=mimetype)\n    response[\"Last-Modified\"] = http_date(statobj.st_mtime)\n    if stat.S_ISREG(statobj.st_mode):\n        response[\"Content-Length\"] = statobj.st_size\n    if encoding:\n        response[\"Content-Encoding\"] = encoding\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def data_received(self, data):\n        self._buffer += data\n        # try to parse the incoming data\n        while self._buffer:\n            try:\n                buf = Buffer(self._buffer)\n                try:\n                    header = header_from_binary(buf)\n                except NotEnoughData:\n                    # a packet should at least contain a header otherwise it is malformed (8 or 12 bytes)\n                    logger.debug('Not enough data while parsing header from client, empty the buffer')\n                    self.transport.close()\n                    return\n                if header.header_size + header.body_size <= header.header_size:\n                    # malformed header prevent invalid access of your buffer\n                    logger.error(f'Got malformed header {header}')\n                    self.transport.close()\n                else:\n                    if len(buf) < header.body_size:\n                        logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,\n                                    len(buf))\n                        return\n                    # we have a complete message\n                    self.messages.put_nowait((header, buf))\n                    self._buffer = self._buffer[(header.header_size + header.body_size):]\n            except Exception:\n                logger.exception('Exception raised while parsing message from client')\n                return\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve(request, path, document_root=None, show_indexes=False):\n    \"\"\"\n    Serve static files below a given point in the directory structure.\n\n    To use, put a URL pattern such as::\n\n        (r'^(?P<path>.*)$', 'django.views.static.serve', {'document_root': '/path/to/my/files/'})\n\n    in your URLconf. You must provide the ``document_root`` param. You may\n    also set ``show_indexes`` to ``True`` if you'd like to serve a basic index\n    of the directory.  This index view will use the template hardcoded below,\n    but if you'd like to override it, you can create a template called\n    ``static/directory_index.html``.\n    \"\"\"\n    path = posixpath.normpath(unquote(path))\n    path = path.lstrip('/')\n    newpath = ''\n    for part in path.split('/'):\n        if not part:\n            # Strip empty path components.\n            continue\n        drive, part = os.path.splitdrive(part)\n        head, part = os.path.split(part)\n        if part in (os.curdir, os.pardir):\n            # Strip '.' and '..' in path.\n            continue\n        newpath = os.path.join(newpath, part).replace('\\\\', '/')\n    if newpath and path != newpath:\n        return HttpResponseRedirect(newpath)\n    fullpath = os.path.join(document_root, newpath)\n    if os.path.isdir(fullpath):\n        if show_indexes:\n            return directory_index(newpath, fullpath)\n        raise Http404(_(\"Directory indexes are not allowed here.\"))\n    if not os.path.exists(fullpath):\n        raise Http404(_('\"%(path)s\" does not exist') % {'path': fullpath})\n    # Respect the If-Modified-Since header.\n    statobj = os.stat(fullpath)\n    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                              statobj.st_mtime, statobj.st_size):\n        return HttpResponseNotModified()\n    content_type, encoding = mimetypes.guess_type(fullpath)\n    content_type = content_type or 'application/octet-stream'\n    f = open(fullpath, 'rb')\n    response = StreamingHttpResponse(iter(lambda: f.read(STREAM_CHUNK_SIZE), b''),\n                                     content_type=content_type)\n    response[\"Last-Modified\"] = http_date(statobj.st_mtime)\n    if stat.S_ISREG(statobj.st_mode):\n        response[\"Content-Length\"] = statobj.st_size\n    if encoding:\n        response[\"Content-Encoding\"] = encoding\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def remarshal(\n    input: Path | str,\n    output: Path | str,\n    input_format: str,\n    output_format: str,\n    *,\n    json_indent: Union[int, None] = None,\n    max_nodes: int = DEFAULT_MAX_NODES,\n    ordered: bool = True,\n    stringify: bool = False,\n    transform: Union[Callable[[Document], Document], None] = None,\n    unwrap: Union[str, None] = None,\n    wrap: Union[str, None] = None,\n    yaml_options: Dict[Any, Any] = {},\n) -> None:\n    input_file = None\n    output_file = None\n\n    try:\n        input_file = sys.stdin.buffer if input == \"-\" else Path(input).open(\"rb\")\n        output_file = sys.stdout.buffer if output == \"-\" else Path(output).open(\"wb\")\n\n        input_data = input_file.read()\n        if not isinstance(input_data, bytes):\n            msg = \"input_data must be bytes\"\n            raise TypeError(msg)\n\n        parsed = decode(input_format, input_data)\n\n        validate_node_count(parsed, limit=max_nodes)\n\n        if unwrap is not None:\n            if not isinstance(parsed, Mapping):\n                msg = (\n                    f\"Top-level value of type '{type(parsed).__name__}' \"\n                    \"cannot be unwrapped\"\n                )\n                raise TypeError(msg)\n            parsed = parsed[unwrap]\n        if wrap is not None:\n            temp = {}\n            temp[wrap] = parsed\n            parsed = temp\n\n        if transform:\n            parsed = transform(parsed)\n\n        encoded = encode(\n            output_format,\n            parsed,\n            json_indent=json_indent,\n            ordered=ordered,\n            stringify=stringify,\n            yaml_options=yaml_options,\n        )\n\n        output_file.write(encoded)\n    finally:\n        if input_file is not None:\n            input_file.close()\n        if output != \"-\" and output_file is not None:\n            output_file.close()\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def serve(request, path, document_root=None, show_indexes=False):\n    \"\"\"\n    Serve static files below a given point in the directory structure.\n\n    To use, put a URL pattern such as::\n\n        (r'^(?P<path>.*)$', 'django.views.static.serve', {'document_root' : '/path/to/my/files/'})\n\n    in your URLconf. You must provide the ``document_root`` param. You may\n    also set ``show_indexes`` to ``True`` if you'd like to serve a basic index\n    of the directory.  This index view will use the template hardcoded below,\n    but if you'd like to override it, you can create a template called\n    ``static/directory_index.html``.\n    \"\"\"\n    path = posixpath.normpath(unquote(path))\n    path = path.lstrip('/')\n    newpath = ''\n    for part in path.split('/'):\n        if not part:\n            # Strip empty path components.\n            continue\n        drive, part = os.path.splitdrive(part)\n        head, part = os.path.split(part)\n        if part in (os.curdir, os.pardir):\n            # Strip '.' and '..' in path.\n            continue\n        newpath = os.path.join(newpath, part).replace('\\\\', '/')\n    if newpath and path != newpath:\n        return HttpResponseRedirect(newpath)\n    fullpath = os.path.join(document_root, newpath)\n    if os.path.isdir(fullpath):\n        if show_indexes:\n            return directory_index(newpath, fullpath)\n        raise Http404(_(\"Directory indexes are not allowed here.\"))\n    if not os.path.exists(fullpath):\n        raise Http404(_('\"%(path)s\" does not exist') % {'path': fullpath})\n    # Respect the If-Modified-Since header.\n    statobj = os.stat(fullpath)\n    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                              statobj.st_mtime, statobj.st_size):\n        return HttpResponseNotModified()\n    content_type, encoding = mimetypes.guess_type(fullpath)\n    content_type = content_type or 'application/octet-stream'\n    f = open(fullpath, 'rb')\n    response = CompatibleStreamingHttpResponse(iter(lambda: f.read(STREAM_CHUNK_SIZE), b''),\n                                               content_type=content_type)\n    response[\"Last-Modified\"] = http_date(statobj.st_mtime)\n    if stat.S_ISREG(statobj.st_mode):\n        response[\"Content-Length\"] = statobj.st_size\n    if encoding:\n        response[\"Content-Encoding\"] = encoding\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def execute(self, image_id, file_path):\n        \"\"\"Does the actual introspection\n\n        :param image_id: Glance image ID\n        :param file_path: Path to the file being introspected\n        \"\"\"\n\n        try:\n            stdout, stderr = putils.trycmd('qemu-img', 'info',\n                                           '--output=json', file_path,\n                                           prlimit=utils.QEMU_IMG_PROC_LIMITS,\n                                           log_errors=putils.LOG_ALL_ERRORS)\n        except OSError as exc:\n            # NOTE(flaper87): errno == 2 means the executable file\n            # was not found. For now, log an error and move forward\n            # until we have a better way to enable/disable optional\n            # tasks.\n            if exc.errno != 2:\n                with excutils.save_and_reraise_exception():\n                    exc_message = encodeutils.exception_to_unicode(exc)\n                    msg = _LE('Failed to execute introspection '\n                              '%(task_id)s: %(exc)s')\n                    LOG.error(msg, {'task_id': self.task_id,\n                                    'exc': exc_message})\n            return\n\n        if stderr:\n            raise RuntimeError(stderr)\n\n        metadata = json.loads(stdout)\n        new_image = self.image_repo.get(image_id)\n        new_image.virtual_size = metadata.get('virtual-size', 0)\n        new_image.disk_format = metadata.get('format')\n        self.image_repo.save(new_image)\n        LOG.debug(\"%(task_id)s: Introspection successful: %(file)s\",\n                  {'task_id': self.task_id, 'file': file_path})\n        return new_image\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def parse(self):\n        # Call the actual parse routine and close all open files in case of\n        # errors. This is needed because if exceptions are thrown the\n        # MultiPartParser will not be garbage collected immediately and\n        # resources would be kept alive. This is only needed for errors because\n        # the Request object closes all uploaded files at the end of the\n        # request.\n        try:\n            return self._parse()\n        except Exception:\n            if hasattr(self, \"_files\"):\n                for _, files in self._files.lists():\n                    for fileobj in files:\n                        fileobj.close()\n            raise\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _construct_forms(self):\n        # instantiate all the forms and put them in self.forms\n        self.forms = []\n        for i in xrange(min(self.total_form_count(), self.absolute_max)):\n            self.forms.append(self._construct_form(i))\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "def response_for_exception(request, exc):\n    if isinstance(exc, Http404):\n        if settings.DEBUG:\n            response = debug.technical_404_response(request, exc)\n        else:\n            response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)\n\n    elif isinstance(exc, PermissionDenied):\n        response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)\n        log_response(\n            'Forbidden (Permission denied): %s', request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, MultiPartParserError):\n        response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n        log_response(\n            'Bad request (Unable to parse request body): %s', request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    elif isinstance(exc, BadRequest):\n        if settings.DEBUG:\n            response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)\n        else:\n            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n        log_response(\n            '%s: %s', str(exc), request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n    elif isinstance(exc, SuspiciousOperation):\n        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent, TooManyFilesSent)):\n            # POST data can't be accessed again, otherwise the original\n            # exception would be raised.\n            request._mark_post_parse_error()\n\n        # The request logger receives events for any problematic request\n        # The security logger receives events for all SuspiciousOperations\n        security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)\n        security_logger.error(\n            str(exc),\n            extra={'status_code': 400, 'request': request},\n        )\n        if settings.DEBUG:\n            response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)\n        else:\n            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n\n    elif isinstance(exc, SystemExit):\n        # Allow sys.exit() to actually exit. See tickets #1023 and #4701\n        raise\n\n    else:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())\n        log_response(\n            '%s: %s', response.reason_phrase, request.path,\n            response=response,\n            request=request,\n            exc_info=sys.exc_info(),\n        )\n\n    # Force a TemplateResponse to be rendered.\n    if not getattr(response, 'is_rendered', True) and callable(getattr(response, 'render', None)):\n        response = response.render()\n\n    return response\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n#ifndef FIPS_MODULE\n    unsigned l;\n#endif\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    if (dh->params.q != NULL\n        && BN_num_bits(dh->params.q) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_Q_TOO_LARGE);\n        return 0;\n    }\n\n    if (BN_num_bits(dh->params.p) < DH_MIN_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_secure_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else {\n        priv_key = dh->priv_key;\n    }\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else {\n        pub_key = dh->pub_key;\n    }\n    if (generate_new_key) {\n        /* Is it an approved safe prime ?*/\n        if (DH_get_nid(dh) != NID_undef) {\n            int max_strength =\n                    ossl_ifc_ffc_compute_security_bits(BN_num_bits(dh->params.p));\n\n            if (dh->params.q == NULL\n                || dh->length > BN_num_bits(dh->params.q))\n                goto err;\n            /* dh->length = maximum bit length of generated private key */\n            if (!ossl_ffc_generate_private_key(ctx, &dh->params, dh->length,\n                                               max_strength, priv_key))\n                goto err;\n        } else {\n#ifdef FIPS_MODULE\n            if (dh->params.q == NULL)\n                goto err;\n#else\n            if (dh->params.q == NULL) {\n                /* secret exponent length, must satisfy 2^(l-1) <= p */\n                if (dh->length != 0\n                    && dh->length >= BN_num_bits(dh->params.p))\n                    goto err;\n                l = dh->length ? dh->length : BN_num_bits(dh->params.p) - 1;\n                if (!BN_priv_rand_ex(priv_key, l, BN_RAND_TOP_ONE,\n                                     BN_RAND_BOTTOM_ANY, 0, ctx))\n                    goto err;\n                /*\n                 * We handle just one known case where g is a quadratic non-residue:\n                 * for g = 2: p % 8 == 3\n                 */\n                if (BN_is_word(dh->params.g, DH_GENERATOR_2)\n                    && !BN_is_bit_set(dh->params.p, 2)) {\n                    /* clear bit 0, since it won't be a secret anyway */\n                    if (!BN_clear_bit(priv_key, 0))\n                        goto err;\n                }\n            } else\n#endif\n            {\n                /* Do a partial check for invalid p, q, g */\n                if (!ossl_ffc_params_simple_validate(dh->libctx, &dh->params,\n                                                     FFC_PARAM_TYPE_DH, NULL))\n                    goto err;\n                /*\n                 * For FFC FIPS 186-4 keygen\n                 * security strength s = 112,\n                 * Max Private key size N = len(q)\n                 */\n                if (!ossl_ffc_generate_private_key(ctx, &dh->params,\n                                                   BN_num_bits(dh->params.q),\n                                                   MIN_STRENGTH,\n                                                   priv_key))\n                    goto err;\n            }\n        }\n    }\n\n    if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))\n        goto err;\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    dh->dirty_cnt++;\n    ok = 1;\n err:\n    if (ok != 1)\n        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);\n\n    if (pub_key != dh->pub_key)\n        BN_free(pub_key);\n    if (priv_key != dh->priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def parse_native_url(url):\n        \"\"\"\n        Support https://maker.ifttt.com/use/WEBHOOK_ID/EVENT_ID\n        \"\"\"\n\n        result = re.match(\n            r'^https?://maker\\.ifttt\\.com/use/'\n            r'(?P<webhook_id>[A-Z0-9_-]+)'\n            r'((?P<events>(/[A-Z0-9_-]+)+))?'\n            r'/?(?P<params>\\?.+)?$', url, re.I)\n\n        if result:\n            return NotifyIFTTT.parse_url(\n                '{schema}://{webhook_id}{events}{params}'.format(\n                    schema=NotifyIFTTT.secure_protocol,\n                    webhook_id=result.group('webhook_id'),\n                    events='' if not result.group('events')\n                    else '@{}'.format(result.group('events')),\n                    params='' if not result.group('params')\n                    else result.group('params')))\n\n        return None\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def getlength(self, text, *args, **kwargs):\n        \"\"\"\n        Returns length (in pixels) of given text.\n        This is the amount by which following text should be offset.\n\n        .. versionadded:: 9.2.0\n        \"\"\"\n        _string_length_check(text)\n        width, height = self.font.getsize(text)\n        return width\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "        def _get_insert_token(token):\n            \"\"\"Returns either a whitespace or the line breaks from token.\"\"\"\n            # See issue484 why line breaks should be preserved.\n            # Note: The actual value for a line break is replaced by \\n\n            # in SerializerUnicode which will be executed in the\n            # postprocessing state.\n            m = re.search(r'((\\r|\\n)+) *$', token.value)\n            if m is not None:\n                return sql.Token(T.Whitespace.Newline, m.groups()[0])\n            else:\n                return sql.Token(T.Whitespace, ' ')\n"}, {"role": "assistant", "content": "False"}]}
{"messages": [{"role": "system", "content": "You are a security expert that is good at static program analysis"}, {"role": "user", "content": "    def _slices_from_text(self, text):\n        last_break = 0\n        for match, context in self._match_potential_end_contexts(text):\n            if self.text_contains_sentbreak(context):\n                yield slice(last_break, match.end())\n                if match.group(\"next_tok\"):\n                    # next sentence starts after whitespace\n                    last_break = match.start(\"next_tok\")\n                else:\n                    # next sentence starts at following punctuation\n                    last_break = match.end()\n        # The last sentence should not contain trailing whitespace.\n        yield slice(last_break, len(text.rstrip()))\n"}, {"role": "assistant", "content": "False"}]}
